<?xml version="1.0"?>
<doc>
    <assembly>
        <name>LiteDB</name>
    </assembly>
    <members>
        <member name="M:LiteDB.LiteCollection`1.Count">
            <summary>
            Get document count using property on collection.
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Count(LiteDB.BsonExpression)">
            <summary>
            Count documents matching a query. This method does not deserialize any document. Needs indexes on query expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Count(System.String,LiteDB.BsonDocument)">
            <summary>
            Count documents matching a query. This method does not deserialize any document. Needs indexes on query expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Count(System.String,LiteDB.BsonValue[])">
            <summary>
            Count documents matching a query. This method does not deserialize any document. Needs indexes on query expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Count(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Count documents matching a query. This method does not deserialize any documents. Needs indexes on query expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.LongCount">
            <summary>
            Get document count using property on collection.
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.LongCount(LiteDB.BsonExpression)">
            <summary>
            Count documents matching a query. This method does not deserialize any documents. Needs indexes on query expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.LongCount(System.String,LiteDB.BsonDocument)">
            <summary>
            Count documents matching a query. This method does not deserialize any documents. Needs indexes on query expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.LongCount(System.String,LiteDB.BsonValue[])">
            <summary>
            Count documents matching a query. This method does not deserialize any documents. Needs indexes on query expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.LongCount(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Count documents matching a query. This method does not deserialize any documents. Needs indexes on query expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Exists(LiteDB.BsonExpression)">
            <summary>
            Returns true if query returns any document. This method does not deserialize any document. Needs indexes on query expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Exists(System.String,LiteDB.BsonDocument)">
            <summary>
            Returns true if query returns any document. This method does not deserialize any document. Needs indexes on query expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Exists(System.String,LiteDB.BsonValue[])">
            <summary>
            Returns true if query returns any document. This method does not deserialize any document. Needs indexes on query expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Exists(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Returns true if query returns any document. This method does not deserialize any document. Needs indexes on query expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Min(LiteDB.BsonExpression)">
            <summary>
            Returns the min value from specified key value in collection
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Min">
            <summary>
            Returns the min value of _id index
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Min``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Returns the min value from specified key value in collection
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Max(LiteDB.BsonExpression)">
            <summary>
            Returns the max value from specified key value in collection
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Max">
            <summary>
            Returns the max _id index key value
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Max``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Returns the last/max field using a linq expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Delete(LiteDB.BsonValue)">
            <summary>
            Delete a single document on collection based on _id index. Returns true if document was deleted
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.DeleteMany(LiteDB.BsonExpression)">
            <summary>
            Delete all documents based on predicate expression. Returns how many documents was deleted
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.DeleteMany(System.String,LiteDB.BsonDocument)">
            <summary>
            Delete all documents based on predicate expression. Returns how many documents was deleted
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.DeleteMany(System.String,LiteDB.BsonValue[])">
            <summary>
            Delete all documents based on predicate expression. Returns how many documents was deleted
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.DeleteMany(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Delete all documents based on predicate expression. Returns how many documents was deleted
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Query">
            <summary>
            Return a new LiteQueryable to build more complex queries
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Find(LiteDB.BsonExpression,System.Int32,System.Int32)">
            <summary>
            Find documents inside a collection using predicate expression.
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Find(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}},System.Int32,System.Int32)">
            <summary>
            Find documents inside a collection using predicate expression.
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.FindById(LiteDB.BsonValue)">
            <summary>
            Find a document using Document Id. Returns null if not found.
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.FindOne(LiteDB.BsonExpression)">
            <summary>
            Find the first document using predicate expression. Returns null if not found
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.FindOne(System.String,LiteDB.BsonDocument)">
            <summary>
            Find the first document using predicate expression. Returns null if not found
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.FindOne(LiteDB.BsonExpression,LiteDB.BsonValue[])">
            <summary>
            Find the first document using predicate expression. Returns null if not found
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.FindOne(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Find the first document using predicate expression. Returns null if not found
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.FindAll">
            <summary>
            Returns all documents inside collection order by _id index.
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Include``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Run an include action in each document returned by Find(), FindById(), FindOne() and All() methods to load DbRef documents
            Returns a new Collection with this action included
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Include(LiteDB.BsonExpression)">
            <summary>
            Run an include action in each document returned by Find(), FindById(), FindOne() and All() methods to load DbRef documents
            Returns a new Collection with this action included
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.EnsureIndex(System.String,LiteDB.BsonExpression,System.Boolean)">
            <summary>
            Create a new permanent index in all documents inside this collections if index not exists already. Returns true if index was created or false if already exits
            </summary>
            <param name="name">Index name - unique name for this collection</param>
            <param name="expression">Create a custom expression function to be indexed</param>
            <param name="unique">If is a unique index</param>
        </member>
        <member name="M:LiteDB.LiteCollection`1.EnsureIndex(LiteDB.BsonExpression,System.Boolean)">
            <summary>
            Create a new permanent index in all documents inside this collections if index not exists already. Returns true if index was created or false if already exits
            </summary>
            <param name="expression">Document field/expression</param>
            <param name="unique">If is a unique index</param>
        </member>
        <member name="M:LiteDB.LiteCollection`1.EnsureIndex``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Boolean)">
            <summary>
            Create a new permanent index in all documents inside this collections if index not exists already.
            </summary>
            <param name="keySelector">LinqExpression to be converted into BsonExpression to be indexed</param>
            <param name="unique">Create a unique keys index?</param>
        </member>
        <member name="M:LiteDB.LiteCollection`1.EnsureIndex``1(System.String,System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Boolean)">
            <summary>
            Create a new permanent index in all documents inside this collections if index not exists already.
            </summary>
            <param name="name">Index name - unique name for this collection</param>
            <param name="keySelector">LinqExpression to be converted into BsonExpression to be indexed</param>
            <param name="unique">Create a unique keys index?</param>
        </member>
        <member name="M:LiteDB.LiteCollection`1.DropIndex(System.String)">
            <summary>
            Drop index and release slot for another index
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Insert(`0)">
            <summary>
            Insert a new entity to this collection. Document Id must be a new value in collection - Returns document Id
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Insert(LiteDB.BsonValue,`0)">
            <summary>
            Insert a new document to this collection using passed id value.
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Insert(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Insert an array of new documents to this collection. Document Id must be a new value in collection. Can be set buffer size to commit at each N documents
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.InsertBulk(System.Collections.Generic.IEnumerable{`0},System.Int32)">
            <summary>
            Implements bulk insert documents in a collection. Usefull when need lots of documents.
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.GetBsonDocs(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Convert each T document in a BsonDocument, setting autoId for each one
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.RemoveDocId(LiteDB.BsonDocument)">
            <summary>
            Remove document _id if contains a "empty" value (checks for autoId bson type)
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Update(`0)">
            <summary>
            Update a document in this collection. Returns false if not found document in collection
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Update(LiteDB.BsonValue,`0)">
            <summary>
            Update a document in this collection. Returns false if not found document in collection
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Update(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Update all documents
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.UpdateMany(LiteDB.BsonExpression,LiteDB.BsonExpression)">
            <summary>
            Update many document based on merge current document with extend expression (must return a new document). This merge will be applied in all predicate results
            Eg: col.UpdateMany("{Name: UPPER(Name)}", "_id > 0")
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.UpdateMany``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Update many document based on merge current document with extend expression (must return a new document). This merge will be applied in all predicate results
            Eg: col.UpdateMany("{Name: UPPER(Name)}", "_id > 0")
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Upsert(`0)">
            <summary>
            Insert or Update a document in this collection.
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Upsert(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Insert or Update all documents
            </summary>
        </member>
        <member name="M:LiteDB.LiteCollection`1.Upsert(LiteDB.BsonValue,`0)">
            <summary>
            Insert or Update a document in this collection.
            </summary>
        </member>
        <member name="P:LiteDB.LiteCollection`1.Name">
            <summary>
            Get collection name
            </summary>
        </member>
        <member name="T:LiteDB.LiteDatabase">
            <summary>
            The LiteDB database. Used for create a LiteDB instance and use all storage resources. It's the database connection
            </summary>
        </member>
        <member name="P:LiteDB.LiteDatabase.Mapper">
            <summary>
            Get current instance of BsonMapper used in this database instance (can be BsonMapper.Global)
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.#ctor(System.String,LiteDB.BsonMapper)">
            <summary>
            Starts LiteDB database using a connection string for file system database
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.#ctor(LiteDB.ConnectionString,LiteDB.BsonMapper)">
            <summary>
            Starts LiteDB database using a connection string for file system database
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.#ctor(System.IO.Stream,LiteDB.BsonMapper)">
            <summary>
            Starts LiteDB database using a Stream disk
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.#ctor(LiteDB.Engine.IEngineSettings,LiteDB.BsonMapper)">
            <summary>
            Starts LiteDB database using custom LiteEngine settings
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.#ctor(LiteDB.Engine.ILiteEngine,LiteDB.BsonMapper)">
            <summary>
            Starts LiteDB database using custom ILiteEngine implementation
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.GetCollection``1(System.String)">
            <summary>
            Get a collection using a entity class as strong typed document. If collection does not exits, create a new one.
            </summary>
            <param name="name">Collection name (case insensitive)</param>
        </member>
        <member name="M:LiteDB.LiteDatabase.GetCollection``1">
            <summary>
            Get a collection using a name based on typeof(T).Name (BsonMapper.ResolveCollectionName function)
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.GetCollection``1(LiteDB.BsonAutoId)">
            <summary>
            Get a collection using a name based on typeof(T).Name (BsonMapper.ResolveCollectionName function)
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.GetCollection(System.String,LiteDB.BsonAutoId)">
            <summary>
            Get a collection using a generic BsonDocument. If collection does not exits, create a new one.
            </summary>
            <param name="name">Collection name (case insensitive)</param>
            <param name="autoId">Define autoId data type (when document contains no _id field)</param>
        </member>
        <member name="M:LiteDB.LiteDatabase.BeginTrans">
            <summary>
            Initialize a new transaction. Transaction are created "per-thread". There is only one single transaction per thread.
            Return true if transaction was created or false if current thread already in a transaction.
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.Commit">
            <summary>
            Commit current transaction
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.Rollback">
            <summary>
            Rollback current transaction
            </summary>
        </member>
        <member name="P:LiteDB.LiteDatabase.FileStorage">
            <summary>
            Returns a special collection for storage files/stream inside datafile. Use _files and _chunks collection names. FileId is implemented as string. Use "GetStorage" for custom options
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.GetStorage``1(System.String,System.String)">
            <summary>
            Get new instance of Storage using custom FileId type, custom "_files" collection name and custom "_chunks" collection. LiteDB support multiples file storages (using different files/chunks collection names)
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.GetCollectionNames">
            <summary>
            Get all collections name inside this database.
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.CollectionExists(System.String)">
            <summary>
            Checks if a collection exists on database. Collection name is case insensitive
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.DropCollection(System.String)">
            <summary>
            Drop a collection and all data + indexes
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.RenameCollection(System.String,System.String)">
            <summary>
            Rename a collection. Returns false if oldName does not exists or newName already exists
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.Execute(System.String,LiteDB.BsonDocument)">
            <summary>
            Execute SQL commands and return as data reader
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.Execute(System.String,LiteDB.BsonValue[])">
            <summary>
            Execute SQL commands and return as data reader
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.Shrink">
            <summary>
            Reduce disk size re-arranging unused spaces.
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.Checkpoint">
            <summary>
            Do datafile WAL checkpoint. Copy all commited transaction in log file into datafile.
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.Analyze(System.String[])">
            <summary>
            Analyze indexes in collections to better index choose decision
            </summary>
        </member>
        <member name="M:LiteDB.LiteDatabase.Vaccum">
            <summary>
            Analyze all database to find-and-fix non linked empty pages
            </summary>
        </member>
        <member name="P:LiteDB.LiteDatabase.UserVersion">
            <summary>
            Get/Set database user version - use this version number to control database change model
            </summary>
        </member>
        <member name="T:LiteDB.LiteQueryable`1">
            <summary>
            An IQueryable-like class to write fluent query in LiteDB. Supports Where, OrderBy, GroupBy, Select, Limit/Offset. Execute query as BsonDataReader, IEnumerable, List
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Include``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Load cross reference documents from path expression (DbRef reference)
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Include(LiteDB.BsonExpression)">
            <summary>
            Load cross reference documents from path expression (DbRef reference)
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Include(System.Collections.Generic.List{LiteDB.BsonExpression})">
            <summary>
            Load cross reference documents from path expression (DbRef reference)
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Where(LiteDB.BsonExpression)">
            <summary>
            Filters a sequence of documents based on a predicate expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Where(System.String,LiteDB.BsonDocument)">
            <summary>
            Filters a sequence of documents based on a predicate expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Where(System.String,LiteDB.BsonValue[])">
            <summary>
            Filters a sequence of documents based on a predicate expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Where(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Filters a sequence of documents based on a predicate expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Where(System.Boolean,LiteDB.BsonExpression)">
            <summary>
            Filters a sequence of documents based on a predicate expression. Will apply filter only if condition are true
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Where(System.Boolean,LiteDB.BsonExpression,LiteDB.BsonDocument)">
            <summary>
            Filters a sequence of documents based on a predicate expression. Will apply filter only if condition are true
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Where(System.Boolean,LiteDB.BsonExpression,LiteDB.BsonValue[])">
            <summary>
            Filters a sequence of documents based on a predicate expression. Will apply filter only if condition are true
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Where(System.Boolean,System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Filters a sequence of documents based on a predicate expression. Will apply filter only if condition are true
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.ForUpdate">
            <summary>
            Execute query locking collection in write mode. This is avoid any other thread change results after read document and before transaction ends
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Offset(System.Int32)">
            <summary>
            Bypasses a specified number of documents in resultset and retun the remaining documents (same as Skip)
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Skip(System.Int32)">
            <summary>
            Bypasses a specified number of documents in resultset and retun the remaining documents (same as Offset)
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Limit(System.Int32)">
            <summary>
            Return a specified number of contiguous documents from start of resultset
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.OrderBy(LiteDB.BsonExpression,System.Int32)">
            <summary>
            Sort the documents of resultset in ascending (or descending) order according to a key (support only one OrderBy)
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.OrderBy``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Int32)">
            <summary>
            Sort the documents of resultset in ascending (or descending) order according to a key (support only one OrderBy)
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.OrderByDescending(LiteDB.BsonExpression)">
            <summary>
            Sort the documents of resultset in descending order according to a key (support only one OrderBy)
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.OrderByDescending``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Sort the documents of resultset in descending order according to a key (support only one OrderBy)
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Select(LiteDB.BsonExpression)">
            <summary>
            Project each document of resultset into a new document/value based on selector expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Select``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Project each document of resultset into a new document/value based on selector expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.SelectAll(LiteDB.BsonExpression)">
            <summary>
            Project each document of resultset into a new document/value based on selector expression
            Apply expression function over all results and will output a single result
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.SelectAll``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Project each document of resultset into a new document/value based on selector expression
            Apply expression function over all results and will output a single result
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.GroupBy(LiteDB.BsonExpression)">
            <summary>
            Groups the documents of resultset according to a specified key selector expression (support only one GroupBy)
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.GroupBy``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Groups the documents of resultset according to a specified key selector expression (support only one GroupBy)
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Having(LiteDB.BsonExpression)">
            <summary>
            Filter documents after group by pipe according to predicate expression (requires GroupBy and support only one Having)
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Having(System.Linq.Expressions.Expression{System.Func{`0,System.Boolean}})">
            <summary>
            Filter documents after group by pipe according to predicate expression (requires GroupBy and support only one Having)
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.ToValues">
            <summary>
            Return query and result only values (not only documents)
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.ExecuteReader">
            <summary>
            Execute query and returns resultset as generic BsonDataReader
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.ExecuteScalar">
            <summary>
            Execute query and return single value
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.GetPlan">
            <summary>
            Get execution plan over current query definition to see how engine will execute query
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.ToEnumerable">
            <summary>
            Execute query returning IEnumerable results
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.ToList">
            <summary>
            Execute query and return results as a List
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.ToArray">
            <summary>
            Execute query and return results as an Array
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Single">
            <summary>
            Returns the only document of resultset, and throw an exception if there not exactly one document in the sequence
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.SingleOrDefault">
            <summary>
            Returns the only document of resultset, or null if resultset are empty; this method throw an exception if there not exactly one document in the sequence
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.First">
            <summary>
            Returns first document of resultset
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.FirstOrDefault">
            <summary>
            Returns first document of resultset or null if resultset are empty
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Count">
            <summary>
            Execute Count methos in filter query
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.LongCount">
            <summary>
            Execute Count methos in filter query
            </summary>
        </member>
        <member name="M:LiteDB.LiteQueryable`1.Exists">
            <summary>
            Returns true/false if query returns any result
            </summary>
        </member>
        <member name="T:LiteDB.LiteRepository">
            <summary>
            The LiteDB repository pattern. A simple way to access your documents in a single class with fluent query api
            </summary>
        </member>
        <member name="P:LiteDB.LiteRepository.Database">
            <summary>
            Get database instance
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.#ctor(System.String,LiteDB.BsonMapper)">
            <summary>
            Starts LiteDB database using a connection string for file system database
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.#ctor(LiteDB.ConnectionString,LiteDB.BsonMapper)">
            <summary>
            Starts LiteDB database using a connection string for file system database
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.#ctor(System.IO.Stream,LiteDB.BsonMapper)">
            <summary>
            Starts LiteDB database using a Stream disk
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Insert``1(``0,System.String)">
            <summary>
            Insert a new document into collection. Document Id must be a new value in collection - Returns document Id
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Insert``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Insert an array of new documents into collection. Document Id must be a new value in collection. Can be set buffer size to commit at each N documents
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Update``1(``0,System.String)">
            <summary>
            Update a document into collection. Returns false if not found document in collection
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Update``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Update all documents
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Upsert``1(``0,System.String)">
            <summary>
            Insert or Update a document based on _id key. Returns true if insert entity or false if update entity
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Upsert``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Insert or Update all documents based on _id key. Returns entity count that was inserted
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Delete``1(LiteDB.BsonValue,System.String)">
            <summary>
            Delete entity based on _id key
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.DeleteMany``1(LiteDB.BsonExpression,System.String)">
            <summary>
            Delete entity based on Query
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.DeleteMany``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String)">
            <summary>
            Delete entity based on predicate filter expression
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Query``1(System.String)">
            <summary>
            Returns new instance of LiteQueryable that provides all method to query any entity inside collection. Use fluent API to apply filter/includes an than run any execute command, like ToList() or First()
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.SingleById``1(LiteDB.BsonValue,System.String)">
            <summary>
            Search for a single instance of T by Id. Shortcut from Query.SingleById
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Fetch``1(LiteDB.BsonExpression,System.String)">
            <summary>
            Execute Query[T].Where(predicate).ToList();
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Fetch``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String)">
            <summary>
            Execute Query[T].Where(predicate).ToList();
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.First``1(LiteDB.BsonExpression,System.String)">
            <summary>
            Execute Query[T].Where(predicate).First();
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.First``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String)">
            <summary>
            Execute Query[T].Where(predicate).First();
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.FirstOrDefault``1(LiteDB.BsonExpression,System.String)">
            <summary>
            Execute Query[T].Where(predicate).FirstOrDefault();
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.FirstOrDefault``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String)">
            <summary>
            Execute Query[T].Where(predicate).FirstOrDefault();
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Single``1(LiteDB.BsonExpression,System.String)">
            <summary>
            Execute Query[T].Where(predicate).Single();
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.Single``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String)">
            <summary>
            Execute Query[T].Where(predicate).Single();
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.SingleOrDefault``1(LiteDB.BsonExpression,System.String)">
            <summary>
            Execute Query[T].Where(predicate).SingleOrDefault();
            </summary>
        </member>
        <member name="M:LiteDB.LiteRepository.SingleOrDefault``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.String)">
            <summary>
            Execute Query[T].Where(predicate).SingleOrDefault();
            </summary>
        </member>
        <member name="T:LiteDB.BsonFieldAttribute">
            <summary>
            Set a name to this property in BsonDocument
            </summary>
        </member>
        <member name="T:LiteDB.BsonIdAttribute">
            <summary>
            Indicate that property will be used as BsonDocument Id
            </summary>
        </member>
        <member name="T:LiteDB.BsonIgnoreAttribute">
            <summary>
            Indicate that property will not be persist in Bson serialization
            </summary>
        </member>
        <member name="T:LiteDB.BsonRefAttribute">
            <summary>
            Indicate that field are not persisted inside this document but it's a reference for another document (DbRef)
            </summary>
        </member>
        <member name="T:LiteDB.BsonMapper">
            <summary>
            Class that converts your entity class to/from BsonDocument
            If you prefer use a new instance of BsonMapper (not Global), be sure cache this instance for better performance
            Serialization rules:
                - Classes must be "public" with a public constructor (without parameters)
                - Properties must have public getter (can be read-only)
                - Entity class must have Id property, [ClassName]Id property or [BsonId] attribute
                - No circular references
                - Fields are not valid
                - IList, Array supports
                - IDictionary supports (Key must be a simple datatype - converted by ChangeType)
            </summary>
        </member>
        <member name="F:LiteDB.BsonMapper._entities">
            <summary>
            Mapping cache between Class/BsonDocument
            </summary>
        </member>
        <member name="F:LiteDB.BsonMapper._customSerializer">
            <summary>
            Map serializer/deserialize for custom types
            </summary>
        </member>
        <member name="F:LiteDB.BsonMapper._typeInstantiator">
            <summary>
            Type instantiator function to support IoC
            </summary>
        </member>
        <member name="F:LiteDB.BsonMapper.Global">
            <summary>
            Global instance used when no BsonMapper are passed in LiteDatabase ctor
            </summary>
        </member>
        <member name="F:LiteDB.BsonMapper.ResolveFieldName">
            <summary>
            A resolver name for field
            </summary>
        </member>
        <member name="P:LiteDB.BsonMapper.SerializeNullValues">
            <summary>
            Indicate that mapper do not serialize null values (default false)
            </summary>
        </member>
        <member name="P:LiteDB.BsonMapper.TrimWhitespace">
            <summary>
            Apply .Trim() in strings when serialize (default true)
            </summary>
        </member>
        <member name="P:LiteDB.BsonMapper.EmptyStringToNull">
            <summary>
            Convert EmptyString to Null (default true)
            </summary>
        </member>
        <member name="P:LiteDB.BsonMapper.IncludeFields">
            <summary>
            Get/Set that mapper must include fields (default: false)
            </summary>
        </member>
        <member name="P:LiteDB.BsonMapper.IncludeNonPublic">
            <summary>
            Get/Set that mapper must include non public (private, protected and internal) (default: false)
            </summary>
        </member>
        <member name="F:LiteDB.BsonMapper.ResolveMember">
            <summary>
            A custom callback to change MemberInfo behavior when converting to MemberMapper.
            Use mapper.ResolveMember(Type entity, MemberInfo property, MemberMapper documentMappedField)
            Set FieldName to null if you want remove from mapped document
            </summary>
        </member>
        <member name="F:LiteDB.BsonMapper.ResolveCollectionName">
            <summary>
            Custom resolve name collection based on Type 
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.RegisterType``1(System.Func{``0,LiteDB.BsonValue},System.Func{LiteDB.BsonValue,``0})">
            <summary>
            Register a custom type serializer/deserialize function
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.RegisterType(System.Type,System.Func{System.Object,LiteDB.BsonValue},System.Func{LiteDB.BsonValue,System.Object})">
            <summary>
            Register a custom type serializer/deserialize function
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.Entity``1">
            <summary>
            Map your entity class to BsonDocument using fluent API
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.GetExpression``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Resolve LINQ expression into BsonExpression
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.UseCamelCase">
            <summary>
            Use lower camel case resolution for convert property names to field names
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.UseLowerCaseDelimiter(System.Char)">
            <summary>
            Uses lower camel case with delimiter to convert property names to field names
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.GetEntityMapper(System.Type)">
            <summary>
            Get property mapper between typed .NET class and BsonDocument - Cache results
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.BuildEntityMapper(System.Type)">
            <summary>
            Use this method to override how your class can be, by default, mapped from entity to Bson document.
            Returns an EntityMapper from each requested Type
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.GetIdMember(System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo})">
            <summary>
            Gets MemberInfo that refers to Id from a document object.
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.GetTypeMembers(System.Type)">
            <summary>
            Returns all member that will be have mapper between POCO class to document
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.RegisterDbRef(LiteDB.BsonMapper,LiteDB.MemberMapper,System.String)">
            <summary>
            Register a property mapper as DbRef to serialize/deserialize only document reference _id
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.RegisterDbRefItem(LiteDB.BsonMapper,LiteDB.MemberMapper,System.String)">
            <summary>
            Register a property as a DbRef - implement a custom Serialize/Deserialize actions to convert entity to $id, $ref only
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.RegisterDbRefList(LiteDB.BsonMapper,LiteDB.MemberMapper,System.String)">
            <summary>
            Register a property as a DbRefList - implement a custom Serialize/Deserialize actions to convert entity to $id, $ref only
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.ToObject(System.Type,LiteDB.BsonDocument)">
            <summary>
            Deserialize a BsonDocument to entity class
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.ToObject``1(LiteDB.BsonDocument)">
            <summary>
            Deserialize a BsonDocument to entity class
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.Deserialize``1(LiteDB.BsonValue)">
            <summary>
            Deserialize an BsonValue to .NET object typed in T
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.ToDocument(System.Type,System.Object)">
            <summary>
            Serialize a entity class to BsonDocument
            </summary>
        </member>
        <member name="M:LiteDB.BsonMapper.ToDocument``1(``0)">
            <summary>
            Serialize a entity class to BsonDocument
            </summary>
        </member>
        <member name="T:LiteDB.EntityBuilder`1">
            <summary>
            Helper class to modify your entity mapping to document. Can be used instead attribute decorates
            </summary>
        </member>
        <member name="M:LiteDB.EntityBuilder`1.Ignore``1(System.Linq.Expressions.Expression{System.Func{`0,``0}})">
            <summary>
            Define which property will not be mapped to document
            </summary>
        </member>
        <member name="M:LiteDB.EntityBuilder`1.Field``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.String)">
            <summary>
            Define a custom name for a property when mapping to document
            </summary>
        </member>
        <member name="M:LiteDB.EntityBuilder`1.Id``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.Boolean)">
            <summary>
            Define which property is your document id (primary key). Define if this property supports auto-id
            </summary>
        </member>
        <member name="M:LiteDB.EntityBuilder`1.DbRef``1(System.Linq.Expressions.Expression{System.Func{`0,``0}},System.String)">
            <summary>
            Define a subdocument (or a list of) as a reference
            </summary>
        </member>
        <member name="M:LiteDB.EntityBuilder`1.GetProperty``2(System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Action{LiteDB.MemberMapper})">
            <summary>
            Get a property based on a expression. Eg.: 'x => x.UserId' return string "UserId"
            </summary>
        </member>
        <member name="T:LiteDB.EntityMapper">
            <summary>
            Class to map entity class to BsonDocument
            </summary>
        </member>
        <member name="P:LiteDB.EntityMapper.Members">
            <summary>
            List all type members that will be mapped to/from BsonDocument
            </summary>
        </member>
        <member name="P:LiteDB.EntityMapper.Id">
            <summary>
            Indicate which member is _id
            </summary>
        </member>
        <member name="P:LiteDB.EntityMapper.ForType">
            <summary>
            Indicate which Type this entity mapper is
            </summary>
        </member>
        <member name="M:LiteDB.EntityMapper.GetMember(System.Linq.Expressions.Expression)">
            <summary>
            Resolve expression to get member mapped
            </summary>
        </member>
        <member name="M:LiteDB.LinqExpressionVisitor.VisitLambda``1(System.Linq.Expressions.Expression{``0})">
            <summary>
            Visit :: `x => x.Customer.Name`
            </summary>
        </member>
        <member name="M:LiteDB.LinqExpressionVisitor.VisitParameter(System.Linq.Expressions.ParameterExpression)">
            <summary>
            Visit :: x => `x`.Customer.Name
            </summary>
        </member>
        <member name="M:LiteDB.LinqExpressionVisitor.VisitMember(System.Linq.Expressions.MemberExpression)">
            <summary>
            Visit :: x => x.`Customer.Name`
            </summary>
        </member>
        <member name="M:LiteDB.LinqExpressionVisitor.VisitMethodCall(System.Linq.Expressions.MethodCallExpression)">
            <summary>
            Visit :: x => x.Customer.Name.`ToUpper()`
            </summary>
        </member>
        <member name="M:LiteDB.LinqExpressionVisitor.VisitConstant(System.Linq.Expressions.ConstantExpression)">
            <summary>
            Visit :: x => x.Age + `10` (will create parameter:  `p0`, `p1`, ...)
            </summary>
        </member>
        <member name="M:LiteDB.LinqExpressionVisitor.VisitUnary(System.Linq.Expressions.UnaryExpression)">
            <summary>
            Visit :: x => `!x.Active`
            </summary>
        </member>
        <member name="M:LiteDB.LinqExpressionVisitor.VisitNew(System.Linq.Expressions.NewExpression)">
            <summary>
            Visit :: x => `new { x.Id, x.Name }`
            </summary>
        </member>
        <member name="M:LiteDB.LinqExpressionVisitor.VisitNewArray(System.Linq.Expressions.NewArrayExpression)">
            <summary>
            Visit :: x => `new int[] { 1, 2, 3 }`
            </summary>
        </member>
        <member name="M:LiteDB.LinqExpressionVisitor.VisitBinary(System.Linq.Expressions.BinaryExpression)">
            <summary>
            Visit :: x => x.Id `+` 10
            </summary>
        </member>
        <member name="M:LiteDB.LinqExpressionVisitor.VisitConditional(System.Linq.Expressions.ConditionalExpression)">
            <summary>
            Visit :: x => `x.Id > 0 ? "ok" : "not-ok"`
            </summary>
        </member>
        <member name="M:LiteDB.LinqExpressionVisitor.ResolvePattern(System.String,System.Linq.Expressions.Expression,System.Collections.Generic.IEnumerable{System.Linq.Expressions.Expression})">
            <summary>
            Resolve string pattern using an object + N arguments. Will write over _builder
            </summary>
        </member>
        <member name="M:LiteDB.LinqExpressionVisitor.GetOperator(System.Linq.Expressions.ExpressionType)">
            <summary>
            Get string operator from an Binary expression
            </summary>
        </member>
        <member name="M:LiteDB.LinqExpressionVisitor.ResolveMember(System.Reflection.MemberInfo)">
            <summary>
            Returns document field name for some type member
            </summary>
        </member>
        <member name="M:LiteDB.LinqExpressionVisitor.IsMethodIndexEval(System.Linq.Expressions.MethodCallExpression,System.Linq.Expressions.Expression@,System.Linq.Expressions.Expression@)">
            <summary>
            Define if this method is index access and must eval index value (do not use parameter)
            </summary>
        </member>
        <member name="M:LiteDB.LinqExpressionVisitor.VisitAsPredicate(System.Linq.Expressions.Expression,System.Boolean)">
            <summary>
            Visit expression but, if ensurePredicate = true, force expression be a predicate (appending ` = true`)
            </summary>
        </member>
        <member name="M:LiteDB.LinqExpressionVisitor.Evaluate(System.Linq.Expressions.Expression)">
            <summary>
            Compile and execute expression (can be cached)
            </summary>
        </member>
        <member name="T:LiteDB.ParameterExpressionVisitor">
            <summary>
            Class used to test in an Expression member expression is based on parameter `x => x.Name` or variable `x => externalVar`
            </summary>
        </member>
        <member name="M:LiteDB.Sql.DateDiff(System.String,System.DateTime,System.DateTime)">
            <summary>
            Get difference of 2 dates. Can define type of date internval. Use dateInterval: "y" (or "year"), "M" (or "month"), "d" (or "day"), "h" (or "hour"), "m" (or "minute"), "s" or ("second").
            </summary>
        </member>
        <member name="T:LiteDB.MemberMapper">
            <summary>
            Internal representation for a .NET member mapped to BsonDocument
            </summary>
        </member>
        <member name="P:LiteDB.MemberMapper.AutoId">
            <summary>
            If member is Id, indicate that are AutoId
            </summary>
        </member>
        <member name="P:LiteDB.MemberMapper.MemberName">
            <summary>
            Member name
            </summary>
        </member>
        <member name="P:LiteDB.MemberMapper.DataType">
            <summary>
            Member returns data type
            </summary>
        </member>
        <member name="P:LiteDB.MemberMapper.FieldName">
            <summary>
            Converted document field name
            </summary>
        </member>
        <member name="P:LiteDB.MemberMapper.Getter">
            <summary>
            Delegate method to get value from entity instance
            </summary>
        </member>
        <member name="P:LiteDB.MemberMapper.Setter">
            <summary>
            Delegate method to set value to entity instance
            </summary>
        </member>
        <member name="P:LiteDB.MemberMapper.Serialize">
            <summary>
            When used, can be define a serialization function from entity class to bson value
            </summary>
        </member>
        <member name="P:LiteDB.MemberMapper.Deserialize">
            <summary>
            When used, can define a deserialization function from bson value
            </summary>
        </member>
        <member name="P:LiteDB.MemberMapper.IsDbRef">
            <summary>
            Is this property an DbRef? Must implement Serialize/Deserialize delegates
            </summary>
        </member>
        <member name="P:LiteDB.MemberMapper.IsList">
            <summary>
            Indicate that this property contains an list of elements (IEnumerable)
            </summary>
        </member>
        <member name="P:LiteDB.MemberMapper.UnderlyingType">
            <summary>
            When property is an array of items, gets underlying type (otherwise is same type of PropertyType)
            </summary>
        </member>
        <member name="T:LiteDB.Reflection">
            <summary>
            Helper class to get entity properties and map as BsonValue
            </summary>
            <summary>
            Using Expressions is the easy and fast way to create classes, structs, get/set fields/properties. But it not works in NET35
            </summary>
        </member>
        <member name="M:LiteDB.Reflection.CreateInstance(System.Type)">
            <summary>
            Create a new instance from a Type
            </summary>
        </member>
        <member name="M:LiteDB.Reflection.UnderlyingTypeOf(System.Type)">
            <summary>
            Get underlying get - using to get inner Type from Nullable type
            </summary>
        </member>
        <member name="M:LiteDB.Reflection.GetListItemType(System.Type)">
            <summary>
            Get item type from a generic List or Array
            </summary>
        </member>
        <member name="M:LiteDB.Reflection.IsList(System.Type)">
            <summary>
            Returns true if Type is any kind of Array/IList/ICollection/....
            </summary>
        </member>
        <member name="M:LiteDB.Reflection.IsDictionary(System.Type)">
            <summary>
            Returns if Type is a generic Dictionary
            </summary>
        </member>
        <member name="M:LiteDB.Reflection.SelectMember(System.Collections.Generic.IEnumerable{System.Reflection.MemberInfo},System.Func{System.Reflection.MemberInfo,System.Boolean}[])">
            <summary>
            Select member from a list of member using predicate order function to select
            </summary>
        </member>
        <member name="T:LiteDB.LiteFileInfo`1">
            <summary>
            Represents a file inside storage collection
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileInfo`1.OpenRead">
            <summary>
            Open file stream to read from database
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileInfo`1.OpenWrite">
            <summary>
            Open file stream to write to database
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileInfo`1.CopyTo(System.IO.Stream)">
            <summary>
            Copy file content to another stream
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileInfo`1.SaveAs(System.String,System.Boolean)">
            <summary>
            Save file content to a external file
            </summary>
        </member>
        <member name="F:LiteDB.LiteFileStream`1.MAX_CHUNK_SIZE">
            <summary>
            Number of bytes on each chunk document to store
            </summary>
        </member>
        <member name="P:LiteDB.LiteFileStream`1.FileInfo">
            <summary>
            Get file information
            </summary>
        </member>
        <member name="M:LiteDB.LiteFileStream`1.WriteChunks(System.Boolean)">
            <summary>
            Consume all _buffer bytes and write to chunk collection
            </summary>
        </member>
        <member name="T:LiteDB.LiteStorage`1">
            <summary>
            Storage is a special collection to store files and streams. 
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage`1.FindById(`0)">
            <summary>
            Find a file inside datafile and returns LiteFileInfo instance. Returns null if not found
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage`1.Find(LiteDB.BsonExpression)">
            <summary>
            Find all files that match with predicate expression.
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage`1.Find(System.String,LiteDB.BsonDocument)">
            <summary>
            Find all files that match with predicate expression.
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage`1.Find(System.String,LiteDB.BsonValue[])">
            <summary>
            Find all files that match with predicate expression.
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage`1.Find(System.Linq.Expressions.Expression{System.Func{LiteDB.LiteFileInfo{`0},System.Boolean}})">
            <summary>
            Find all files that match with predicate expression.
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage`1.FindAll">
            <summary>
            Find all files inside file collections
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage`1.Exists(`0)">
            <summary>
            Returns if a file exisits in database
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage`1.OpenWrite(`0,System.String,LiteDB.BsonDocument)">
            <summary>
            Open/Create new file storage and returns linked Stream to write operations.
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage`1.Upload(`0,System.String,System.IO.Stream,LiteDB.BsonDocument)">
            <summary>
            Upload a file based on stream data
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage`1.Upload(`0,System.String)">
            <summary>
            Upload a file based on file system data
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage`1.SetMetadata(`0,LiteDB.BsonDocument)">
            <summary>
            Update metadata on a file. File must exist.
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage`1.OpenRead(`0)">
            <summary>
            Load data inside storage and returns as Stream
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage`1.Download(`0,System.IO.Stream)">
            <summary>
            Copy all file content to a steam
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage`1.Download(`0,System.String,System.Boolean)">
            <summary>
            Copy all file content to a file
            </summary>
        </member>
        <member name="M:LiteDB.LiteStorage`1.Delete(`0)">
            <summary>
            Delete a file inside datafile and all metadata related
            </summary>
        </member>
        <member name="T:LiteDB.ConnectionString">
            <summary>
            Manage ConnectionString to connect and create databases. Connection string are NameValue using Name1=Value1; Name2=Value2
            </summary>
        </member>
        <member name="P:LiteDB.ConnectionString.Filename">
            <summary>
            "filename": Full path or relative path from DLL directory
            </summary>
        </member>
        <member name="P:LiteDB.ConnectionString.Timeout">
            <summary>
            "timeout": Timeout for waiting unlock operations (default: 1 minute)
            </summary>
        </member>
        <member name="P:LiteDB.ConnectionString.InitialSize">
            <summary>
            "initial size": If database is new, initialize with allocated space - support KB, MB, GB (default: 0 bytes)
            </summary>
        </member>
        <member name="P:LiteDB.ConnectionString.LimitSize">
            <summary>
            "limit size": Max limit of datafile - support KB, MB, GB (default: long.MaxValue - no limit)
            </summary>
        </member>
        <member name="P:LiteDB.ConnectionString.Log">
            <summary>
            "log": Debug messages from database - use `LiteDatabase.Log` (default: Logger.NONE)
            </summary>
        </member>
        <member name="P:LiteDB.ConnectionString.UtcDate">
            <summary>
            "utc": Returns date in UTC timezone from BSON deserialization (default: false - LocalTime)
            </summary>
        </member>
        <member name="M:LiteDB.ConnectionString.#ctor">
            <summary>
            Initialize empty connection string
            </summary>
        </member>
        <member name="M:LiteDB.ConnectionString.#ctor(System.String)">
            <summary>
            Initialize connection string parsing string in "key1=value1;key2=value2;...." format or only "filename" as default (when no ; char found)
            </summary>
        </member>
        <member name="P:LiteDB.ConnectionString.Item(System.String)">
            <summary>
            Get value from parsed connection string. Returns null if not found
            </summary>
        </member>
        <member name="T:LiteDB.Query">
            <summary>
            Class is a result from optimized QueryBuild. Indicate how engine must run query - there is no more decisions to engine made, must only execute as query was defined
            </summary>
        </member>
        <member name="F:LiteDB.Query.Ascending">
            <summary>
            Indicate when a query must execute in ascending order
            </summary>
        </member>
        <member name="F:LiteDB.Query.Descending">
            <summary>
            Indicate when a query must execute in descending order
            </summary>
        </member>
        <member name="M:LiteDB.Query.All(System.String,System.Int32)">
            <summary>
            Returns all documents that value are equals to value (=)
            </summary>
        </member>
        <member name="M:LiteDB.Query.EQ(System.String,LiteDB.BsonValue)">
            <summary>
            Returns all documents that value are equals to value (=)
            </summary>
        </member>
        <member name="M:LiteDB.Query.LT(System.String,LiteDB.BsonValue)">
            <summary>
            Returns all documents that value are less than value (&lt;)
            </summary>
        </member>
        <member name="M:LiteDB.Query.LTE(System.String,LiteDB.BsonValue)">
            <summary>
            Returns all documents that value are less than or equals value (&lt;=)
            </summary>
        </member>
        <member name="M:LiteDB.Query.GT(System.String,LiteDB.BsonValue)">
            <summary>
            Returns all document that value are greater than value (&gt;)
            </summary>
        </member>
        <member name="M:LiteDB.Query.GTE(System.String,LiteDB.BsonValue)">
            <summary>
            Returns all documents that value are greater than or equals value (&gt;=)
            </summary>
        </member>
        <member name="M:LiteDB.Query.Between(System.String,LiteDB.BsonValue,LiteDB.BsonValue)">
            <summary>
            Returns all document that values are between "start" and "end" values (BETWEEN)
            </summary>
        </member>
        <member name="M:LiteDB.Query.StartsWith(System.String,System.String)">
            <summary>
            Returns all documents that starts with value (LIKE)
            </summary>
        </member>
        <member name="M:LiteDB.Query.Contains(System.String,System.String)">
            <summary>
            Returns all documents that contains value (CONTAINS)
            </summary>
        </member>
        <member name="M:LiteDB.Query.Not(System.String,LiteDB.BsonValue)">
            <summary>
            Returns all documents that are not equals to value (not equals)
            </summary>
        </member>
        <member name="M:LiteDB.Query.In(System.String,LiteDB.BsonArray)">
            <summary>
            Returns all documents that has value in values list (IN)
            </summary>
        </member>
        <member name="M:LiteDB.Query.In(System.String,LiteDB.BsonValue[])">
            <summary>
            Returns all documents that has value in values list (IN)
            </summary>
        </member>
        <member name="M:LiteDB.Query.In(System.String,System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Returns all documents that has value in values list (IN)
            </summary>
        </member>
        <member name="M:LiteDB.Query.And(LiteDB.BsonExpression,LiteDB.BsonExpression)">
            <summary>
            Returns document that exists in BOTH queries results. If both queries has indexes, left query has index preference (other side will be run in full scan)
            </summary>
        </member>
        <member name="M:LiteDB.Query.And(LiteDB.BsonExpression[])">
            <summary>
            Returns document that exists in ALL queries results.
            </summary>
        </member>
        <member name="M:LiteDB.Query.Or(LiteDB.BsonExpression,LiteDB.BsonExpression)">
            <summary>
            Returns documents that exists in ANY queries results (Union).
            </summary>
        </member>
        <member name="M:LiteDB.Query.Or(LiteDB.BsonExpression[])">
            <summary>
            Returns document that exists in ANY queries results (Union).
            </summary>
        </member>
        <member name="M:LiteDB.BsonArrayExtensions.ToBsonArray(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Convert an IEnumerable of BsonValues into a single BsonArray with all elements
            </summary>
        </member>
        <member name="T:LiteDB.BsonAutoId">
            <summary>
            All supported BsonTypes supported in AutoId insert operation
            </summary>
        </member>
        <member name="T:LiteDB.BsonDataReader">
            <summary>
            Class to read void, one or a collection of BsonValues. Used in SQL execution commands and query returns. Use local data source (IEnumerable[BsonDocument])
            </summary>
        </member>
        <member name="E:LiteDB.BsonDataReader.FetchNextResult">
            <summary>
            Handler function when NextResult() called - return null if no more data
            </summary>
        </member>
        <member name="M:LiteDB.BsonDataReader.#ctor">
            <summary>
            Initialize with no value
            </summary>
        </member>
        <member name="M:LiteDB.BsonDataReader.#ctor(LiteDB.BsonValue,System.String)">
            <summary>
            Initialize with a single value
            </summary>
        </member>
        <member name="M:LiteDB.BsonDataReader.#ctor(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.String)">
            <summary>
            Initialize with an IEnumerable data source
            </summary>
        </member>
        <member name="M:LiteDB.BsonDataReader.NextResult">
            <summary>
            Advances the data reader to the next result
            </summary>
        </member>
        <member name="P:LiteDB.BsonDataReader.HasValues">
            <summary>
            Return if has any value in result
            </summary>
        </member>
        <member name="P:LiteDB.BsonDataReader.Current">
            <summary>
            Return current value
            </summary>
        </member>
        <member name="P:LiteDB.BsonDataReader.Collection">
            <summary>
            Return collection name
            </summary>
        </member>
        <member name="M:LiteDB.BsonDataReader.Read">
            <summary>
            Move cursor to next result. Returns true if read was possible
            </summary>
        </member>
        <member name="P:LiteDB.BsonDocument.RawId">
            <summary>
            Get/Set position of this document inside database. It's filled when used in Find operation.
            </summary>
        </member>
        <member name="P:LiteDB.BsonDocument.Item(System.String)">
            <summary>
            Get/Set a field for document. Fields are case sensitive
            </summary>
        </member>
        <member name="M:LiteDB.BsonDocument.Get(System.String,System.Boolean)">
            <summary>
            Get an IEnumerable of values from a json-like path inside document. Use BsonExpression to parse this path
            </summary>
        </member>
        <member name="M:LiteDB.BsonDocument.Extend(LiteDB.BsonDocument)">
            <summary>
            Copy all properties from other document inside this current document
            </summary>
        </member>
        <member name="T:LiteDB.BsonType">
            <summary>
            All supported BsonTypes in sort order
            </summary>
        </member>
        <member name="T:LiteDB.BsonValue">
            <summary>
            Represent a Bson Value used in BsonDocument
            </summary>
        </member>
        <member name="P:LiteDB.BsonValue.Null">
            <summary>
            Represent a Null bson type
            </summary>
        </member>
        <member name="P:LiteDB.BsonValue.MinValue">
            <summary>
            Represent a MinValue bson type
            </summary>
        </member>
        <member name="P:LiteDB.BsonValue.MaxValue">
            <summary>
            Represent a MaxValue bson type
            </summary>
        </member>
        <member name="M:LiteDB.BsonValue.DbRef(LiteDB.BsonValue,System.String)">
            <summary>
            Create a new document used in DbRef => { $id: id, $ref: collection }
            </summary>
        </member>
        <member name="P:LiteDB.BsonValue.Type">
            <summary>
            Indicate BsonType of this BsonValue
            </summary>
        </member>
        <member name="P:LiteDB.BsonValue.RawValue">
            <summary>
            Get internal .NET value object
            </summary>
        </member>
        <member name="F:LiteDB.BsonValue.Destroy">
            <summary>
            Internal destroy method. Works only when used with BsonExpression
            </summary>
        </member>
        <member name="P:LiteDB.BsonValue.Item(System.String)">
            <summary>
            Get/Set a field for document. Fields are case sensitive - Works only when value are document
            </summary>
        </member>
        <member name="P:LiteDB.BsonValue.Item(System.Int32)">
            <summary>
            Get/Set value in array position. Works only when value are array
            </summary>
        </member>
        <member name="M:LiteDB.BsonValue.GetBytesCount(System.Boolean)">
            <summary>
            Returns how many bytes this BsonValue will use to persist in index writes
            </summary>
        </member>
        <member name="T:LiteDB.BsonReader">
            <summary>
            Internal class to deserialize a ChunckStream into a BsonDocument using BSON data format
            </summary>
        </member>
        <member name="M:LiteDB.BsonReader.ReadDocument(System.IO.BinaryReader,System.Collections.Generic.HashSet{System.String})">
            <summary>
            Read a BsonDocument from reader - support select fields ONLY in root level
            </summary>
        </member>
        <member name="M:LiteDB.BsonReader.ReadArray(System.IO.BinaryReader)">
            <summary>
            Read an BsonArray from reader
            </summary>
        </member>
        <member name="M:LiteDB.BsonReader.ReadElement(System.IO.BinaryReader,System.Collections.Generic.HashSet{System.String},System.String@)">
            <summary>
            Reads an element (key-value) from an reader. If remaining != null and name not are in 
            </summary>
        </member>
        <member name="T:LiteDB.BsonSerializer">
            <summary>
            Class to call method for convert BsonDocument to/from byte[] - based on http://bsonspec.org/spec.html
            </summary>
        </member>
        <member name="M:LiteDB.BsonSerializer.Deserialize(System.Byte[],System.Boolean,System.Collections.Generic.HashSet{System.String})">
            <summary>
            Deserialize binary data into BsonDocument
            </summary>
        </member>
        <member name="T:LiteDB.BsonWriter">
            <summary>
            Internal class to serialize a BsonDocument to BSON data format (byte[])
            </summary>
        </member>
        <member name="M:LiteDB.BsonWriter.Serialize(LiteDB.BsonDocument)">
            <summary>
            Main method - Serialize document into lazy ChunkStream
            </summary>
        </member>
        <member name="M:LiteDB.BsonWriter.WriteDocument(System.IO.BinaryWriter,LiteDB.BsonDocument)">
            <summary>
            Write a bson document into ByteWriter
            </summary>
        </member>
        <member name="T:LiteDB.BsonExpression">
            <summary>
            Compile and execute string expressions using BsonDocuments. Used in all document manipulation (transform, filter, indexes, updates). See https://github.com/mbdavid/LiteDB/wiki/Expressions
            </summary>
        </member>
        <member name="P:LiteDB.BsonExpression.Source">
            <summary>
            Get formatted expression
            </summary>
        </member>
        <member name="P:LiteDB.BsonExpression.Type">
            <summary>
            Indicate expression type
            </summary>
        </member>
        <member name="P:LiteDB.BsonExpression.IsImmutable">
            <summary>
            If true, this expression do not change if same document/paramter are passed (only few methods change - like NOW() - or parameters)
            </summary>
        </member>
        <member name="P:LiteDB.BsonExpression.Parameters">
            <summary>
            Get/Set parameter values that will be used on expression execution
            </summary>
        </member>
        <member name="P:LiteDB.BsonExpression.Left">
            <summary>
            In predicate expressions, indicate Left side
            </summary>
        </member>
        <member name="P:LiteDB.BsonExpression.Right">
            <summary>
            In predicate expressions, indicate Rigth side
            </summary>
        </member>
        <member name="P:LiteDB.BsonExpression.Expression">
            <summary>
            Get transformed LINQ expression
            </summary>
        </member>
        <member name="P:LiteDB.BsonExpression.Fields">
            <summary>
            Fill this hashset with all fields used in root level of document (be used to partial deserialize) - "$" means all fields
            </summary>
        </member>
        <member name="P:LiteDB.BsonExpression.IsPredicate">
            <summary>
            Indicate that expression evaluate to TRUE or FALSE (=, >, ...). OR and AND are not considered Predicate expressions
            Predicate expressions must have Left/Right expressions
            </summary>
        </member>
        <member name="P:LiteDB.BsonExpression.IsIndexable">
            <summary>
            This expression can be indexed? To index some expression must contains fields (at least 1) and
            must use only immutable methods and no parameters
            </summary>
        </member>
        <member name="P:LiteDB.BsonExpression.IsValue">
            <summary>
            This expression has no dependency of BsonDocument so can be used as user value (when select index)
            </summary>
        </member>
        <member name="F:LiteDB.BsonExpression._func">
            <summary>
            Compiled Expression into a function to be executed: func(root, current, parameters)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpression.#ctor">
            <summary>
            Only internal ctor (from BsonParserExpression)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpression.op_Implicit(LiteDB.BsonExpression)~System.String">
            <summary>
            Implicit string converter
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpression.op_Implicit(System.String)~LiteDB.BsonExpression">
            <summary>
            Implicit string converter
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpression.Execute(System.Boolean)">
            <summary>
            Execute expression with an empty document (used only for resolve math/functions).
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpression.Execute(LiteDB.BsonDocument,System.Boolean)">
            <summary>
            Execute expression and returns IEnumerable values (can returns NULL if no elements).
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpression.Execute(System.Collections.Generic.IEnumerable{LiteDB.BsonDocument},System.Boolean)">
            <summary>
            Execute expression and returns IEnumerable values (can returns NULL if no elements).
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpression.Execute(System.Collections.Generic.IEnumerable{LiteDB.BsonDocument},System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Boolean)">
            <summary>
            Execute expression and returns IEnumerable values (can returns NULL if no elements).
            </summary>
        </member>
        <member name="P:LiteDB.BsonExpression.Empty">
            <summary>
            Create an empty expression - Return same doc (similar to "$")
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpression.Create(System.String)">
            <summary>
            Parse string and create new instance of BsonExpression - can be cached
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpression.Create(System.String,LiteDB.BsonValue[])">
            <summary>
            Parse string and create new instance of BsonExpression - can be cached
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpression.Create(System.String,LiteDB.BsonDocument)">
            <summary>
            Parse string and create new instance of BsonExpression - can be cached
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpression.Create(LiteDB.Tokenizer,LiteDB.BsonDocument)">
            <summary>
            Parse tokenizer and create new instance of BsonExpression - for now, do not use cache
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpression.Parse(LiteDB.Tokenizer,System.Boolean)">
            <summary>
            Parse and compile string expression and return BsonExpression
            </summary>
        </member>
        <member name="F:LiteDB.BsonExpression._methods">
            <summary>
            Load all static methods from BsonExpressionMethods class. Use a dictionary using name + parameter count
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpression.GetMethod(System.String,System.Int32)">
            <summary>
            Get expression method with same name and same parameter - return null if not found
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpression.RegisterMethod(System.Func{System.Collections.Generic.IEnumerable{LiteDB.BsonValue}})">
            <summary>
            Register a new method to work with BsonExpressions. Method must be public/static method
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpression.RegisterMethod(System.Func{System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue}})">
            <summary>
            Register a new method to work with BsonExpressions. Method must be public/static method
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpression.RegisterMethod(System.Func{System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue}})">
            <summary>
            Register a new method to work with BsonExpressions. Method must be public/static method
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpression.RegisterMethod(System.Func{System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue}})">
            <summary>
            Register a new method to work with BsonExpressions. Method must be public/static method
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.COUNT(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Count all values. Return a single value
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.MIN(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Find minimal value from all values (number values only). Return a single value
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.MAX(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Find max value from all values (number values only). Return a single value
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.FIRST(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Returns first value from an list of values (scan all source)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.LAST(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Returns last value from an list of values
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.AVG(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Find average value from all values (number values only). Return a single value
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.SUM(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Sum all values (number values only). Return a single value
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.ALL(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return "true" only if all values are true
            ALL($.items[*] > 0)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.ANY(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return "true" if any values are true. Run over all results
            ANY($._id = ITEMS([1, 2, 3, 4]))
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.JOIN(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Join all values into a single string with ',' separator. Return a single value
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.JOIN(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Join all values into a single string with a string separator. Return a single value
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.MINVALUE">
            <summary>
            Return a new instance of MINVALUE
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.OBJECTID">
            <summary>
            Create a new OBJECTID value
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.GUID">
            <summary>
            Create a new GUID value
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.NOW">
            <summary>
            Return a new DATETIME (Now)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.NOW_UTC">
            <summary>
            Return a new DATETIME (UtcNow)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.TODAY">
            <summary>
            Return a new DATETIME (Today)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.MAXVALUE">
            <summary>
            Return a new instance of MAXVALUE
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.TO_INT32(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Convert values into INT32. Returns empty if not possible to convert
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.TO_INT64(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Convert values into INT64. Returns empty if not possible to convert
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.TO_DOUBLE(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Convert values into DOUBLE. Returns empty if not possible to convert
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.TO_DECIMAL(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Convert values into DECIMAL. Returns empty if not possible to convert
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.TO_STRING(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Convert values into STRING
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.TO_ARRAY(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return an array from list of values. Support multiple values but returns a single value
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.TO_BINARY(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return an binary from string (base64) values
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.TO_OBJECTID(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Convert values into OBJECTID. Returns empty if not possible to convert
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.TO_GUID(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Convert values into GUID. Returns empty if not possible to convert
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.TO_BOOLEAN(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return converted value into BOOLEAN value
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.TO_DATETIME(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Convert values into DATETIME. Returns empty if not possible to convert
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.TO_DATETIME_UTC(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Convert values into DATETIME. Returns empty if not possible to convert
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.TO_DATETIME(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Create a new instance of DATETIME based on year, month, day (local time)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.TO_DATETIME_UTC(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Create a new instance of DATETIME based on year, month, day (UTC)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.IS_MINVALUE(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return true if value is MINVALUE
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.IS_NULL(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return true if value is NULL
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.IS_INT32(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return true if value is INT32
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.IS_INT64(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return true if value is INT64
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.IS_DOUBLE(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return true if value is DOUBLE
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.IS_DECIMAL(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return true if value is DECIMAL
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.IS_NUMBER(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return true if value is NUMBER (int, double, decimal)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.IS_STRING(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return true if value is STRING
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.IS_DOCUMENT(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return true if value is DOCUMENT
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.IS_ARRAY(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return true if value is ARRAY
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.IS_BINARY(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return true if value is BINARY
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.IS_OBJECTID(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return true if value is OBJECTID
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.IS_GUID(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return true if value is GUID
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.IS_BOOLEAN(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return true if value is BOOLEAN
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.IS_DATETIME(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return true if value is DATETIME
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.IS_MAXVALUE(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return true if value is DATE (alias to DATETIME)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.TO_INT(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Alias to TO_INT32(values)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.TO_LONG(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Alias to TO_INT64(values)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.TO_DATE(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Alias to TO_DATETIME(values) and TO_DATETIME_UTC(values)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.IS_INT(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Alias to IS_INT32(values)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.IS_LONG(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Alias to IS_INT64(values)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.IS_BOOL(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Alias to IS_BOOLEAN(values)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.IS_DATE(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Alias to IS_DATE(values)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.YEAR(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Get year from date
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.MONTH(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Get month from date
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.DAY(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Get day from date
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.HOUR(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Get hour from date
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.MINUTE(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Get minute from date
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.SECOND(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Get seconds from date
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.DATEADD(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Add an interval to date. Use dateInterval: "y" (or "year"), "M" (or "month"), "d" (or "day"), "h" (or "hour"), "m" (or "minute"), "s" or ("second")
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.DATEDIFF(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Returns an interval about 2 dates. Use dateInterval: "y|year", "M|month", "d|day", "h|hour", "m|minute", "s|second"
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.ABS(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Apply absolute value (ABS) method in all number values
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.ROUND(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Round number method in all number values
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.POW(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Implement POWER (x and y)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.JSON(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Parse a JSON string into a new BsonValue
            JSON('{a:1}') = {a:1}
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.EXTEND(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Extend source document with other document. Copy all field from extend to source. Source document will be modified.
            EXTEND($, {a: 2}) = {_id:1, a: 2}
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.ITEMS(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Convert an array into IEnuemrable of values.
            ITEMS([1, 2, null]) = 1, 2, null
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.KEYS(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Get all KEYS names from a document. Support multiple values (document only)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.IIF(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Conditional IF statment. If condition are true, returns TRUE value, otherwise, FALSE value
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.LENGTH(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return length of variant value (valid only for String, Binary, Array or Document [keys])
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.LOWER(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return lower case from string value
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.UPPER(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return UPPER case from string value
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.LTRIM(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Apply Left TRIM (start) from string value
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.RTRIM(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Apply Right TRIM (end) from string value
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.TRIM(System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Apply TRIM from string value
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.INDEXOF(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Reports the zero-based index of the first occurrence of the specified string in this instance
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.INDEXOF(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Reports the zero-based index of the first occurrence of the specified string in this instance
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.SUBSTRING(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Returns substring from string value using index and length (zero-based)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.SUBSTRING(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Returns substring from string value using index and length (zero-based)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.REPLACE(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Returns replaced string changing oldValue with newValue
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.LPAD(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return value string with left padding
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.RPAD(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return value string with right padding
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.SPLIT(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Split string value into enumerate of items
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionMethods.FORMAT(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Return format value string using format definition (same as String.Format("{0:~}", values)).
            </summary>
        </member>
        <member name="T:LiteDB.VolatileAttribute">
            <summary>
            When a method are decorated with this attribute means that this method are not immutable
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionOperators.ADD(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Add two number values. If any side are string, concat left+right as string
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionOperators.MINUS(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Minus two number values
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionOperators.MULTIPLY(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Multiply two number values
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionOperators.DIVIDE(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Divide two number values
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionOperators.MOD(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Mod two number values
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionOperators.EQ(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Test if left and right are same value. Returns true or false
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionOperators.LIKE(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Test if left is "SQL LIKE" with right. Returns true or false. Works only when left and right are string
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionOperators.BETWEEN(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Test if left is between right-array. Returns true or false. Right value must be an array. Support multiple values
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionOperators.GT(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Test if left is greater than right value. Returns true or false
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionOperators.GTE(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Test if left is greater or equals than right value. Returns true or false
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionOperators.LT(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Test if left is less than right value. Returns true or false
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionOperators.LTE(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Test if left is less or equals than right value. Returns true or false
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionOperators.NEQ(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Test if left and right are not same value. Returns true or false
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionOperators.IN(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Test if left are in any value in right side (when right side is an array). If right side is not an array, just implement a simple Equals (=). Returns true or false
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionOperators.AND(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Test left AND right value. Returns true or false
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionOperators.OR(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Test left OR right value. Returns true or false
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionOperators.PARAMETER_PATH(LiteDB.BsonValue,System.String)">
            <summary>
            Returns value from root document (used in parameter). Returns same document if name are empty
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionOperators.MEMBER_PATH(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.String)">
            <summary>
            Return a value from a value as document. If has no name, just return values ($). If value are not a document, do not return anything
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionOperators.ARRAY_PATH(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},System.Int32,LiteDB.BsonExpression,System.Collections.Generic.IEnumerable{LiteDB.BsonDocument},LiteDB.BsonDocument)">
            <summary>
            Returns all values from array according index. If index are MaxValue, return all values
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionOperators.DOCUMENT_INIT(System.String[],System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{LiteDB.BsonValue}})">
            <summary>
            Create multi documents based on key-value pairs on parameters. DOCUMENT('_id', 1)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionOperators.ARRAY_INIT(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{LiteDB.BsonValue}})">
            <summary>
            Return an array from list of values. Support multiple values but returns a single value
            </summary>
        </member>
        <member name="T:LiteDB.BsonExpressionParser">
            <summary>
            Compile and execute simple expressions using BsonDocuments. Used in indexes and updates operations. See https://github.com/mbdavid/LiteDB/wiki/Expressions
            </summary>
        </member>
        <member name="F:LiteDB.BsonExpressionParser._operators">
            <summary>
            Operation definition by methods with defined expression type (operators are in precedence order)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionParser.ParseFullExpression(LiteDB.Tokenizer,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Boolean)">
            <summary>
            Start parse string into linq expression. Read path, function or base type bson values (int, double, bool, string)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionParser.ParseSingleExpression(LiteDB.Tokenizer,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Boolean)">
            <summary>
            Start parse string into linq expression. Read path, function or base type bson values (int, double, bool, string)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionParser.TryParseDouble(LiteDB.Tokenizer)">
            <summary>
            Try parse double number - return null if not double token
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionParser.TryParseInt(LiteDB.Tokenizer)">
            <summary>
            Try parse int number - return null if not int token
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionParser.TryParseBool(LiteDB.Tokenizer)">
            <summary>
            Try parse bool - return null if not bool token
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionParser.TryParseNull(LiteDB.Tokenizer)">
            <summary>
            Try parse null constant - return null if not null token
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionParser.TryParseString(LiteDB.Tokenizer)">
            <summary>
            Try parse string with both single/double quote - return null if not string
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionParser.TryParseDocument(LiteDB.Tokenizer,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Boolean)">
            <summary>
            Try parse json document - return null if not document token
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionParser.TryParseArray(LiteDB.Tokenizer,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Boolean)">
            <summary>
            Try parse array - return null if not array token
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionParser.TryParseParameter(LiteDB.Tokenizer,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Boolean)">
            <summary>
            Try parse parameter - return null if not parameter token
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionParser.TryParseInnerExpression(LiteDB.Tokenizer,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Boolean)">
            <summary>
            Try parse inner expression - return null if not bracket token
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionParser.TryParseMethodCall(LiteDB.Tokenizer,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Boolean)">
            <summary>
            Try parse method call - return null if not method call
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionParser.TryParsePath(LiteDB.Tokenizer,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Boolean)">
            <summary>
            Parse JSON-Path - return null if not method call
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionParser.ParsePath(LiteDB.Tokenizer,System.Linq.Expressions.Expression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Collections.Generic.HashSet{System.String},System.Boolean@,System.Text.StringBuilder)">
            <summary>
            Implement a JSON-Path like navigation on BsonDocument. Support a simple range of paths
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionParser.NewArray(LiteDB.BsonExpression,LiteDB.BsonExpression)">
            <summary>
            Create an array expression with 2 values (used only in BETWEEN statement)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionParser.CreateBinaryExpression(System.String,LiteDB.BsonExpression,LiteDB.BsonExpression)">
            <summary>
            Create new binary expression based in 2 sides expression
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionParser.ReadField(LiteDB.Tokenizer,System.Text.StringBuilder)">
            <summary>
            Get field from simple \w regex or ['comp-lex'] - also, add into source. Can read empty field (root)
            </summary>
        </member>
        <member name="M:LiteDB.BsonExpressionParser.ReadKey(LiteDB.Tokenizer,System.Text.StringBuilder)">
            <summary>
            Read key in document definition with single word or "comp-lex"
            </summary>
        </member>
        <member name="T:LiteDB.JsonReader">
            <summary>
            A class that read a json string using a tokenizer (without regex)
            </summary>
        </member>
        <member name="T:LiteDB.JsonSerializer">
            <summary>
            Static class for serialize/deserialize BsonDocuments into json extended format
            </summary>
        </member>
        <member name="M:LiteDB.JsonSerializer.Serialize(LiteDB.BsonValue,System.Boolean,System.Boolean)">
            <summary>
            Json serialize a BsonValue into a String
            </summary>
        </member>
        <member name="M:LiteDB.JsonSerializer.Serialize(LiteDB.BsonValue,System.IO.TextWriter,System.Boolean,System.Boolean)">
            <summary>
            Json serialize a BsonValue into a TextWriter
            </summary>
        </member>
        <member name="M:LiteDB.JsonSerializer.Serialize(LiteDB.BsonValue,System.Text.StringBuilder,System.Boolean,System.Boolean)">
            <summary>
            Json serialize a BsonValue into a StringBuilder
            </summary>
        </member>
        <member name="M:LiteDB.JsonSerializer.Deserialize(System.String)">
            <summary>
            Deserialize a Json string into a BsonValue
            </summary>
        </member>
        <member name="M:LiteDB.JsonSerializer.Deserialize(System.IO.TextReader)">
            <summary>
            Deserialize a Json TextReader into a BsonValue
            </summary>
        </member>
        <member name="M:LiteDB.JsonSerializer.DeserializeArray(System.String)">
            <summary>
            Deserialize a json array as an IEnumerable of BsonValue
            </summary>
        </member>
        <member name="M:LiteDB.JsonSerializer.DeserializeArray(System.IO.TextReader)">
            <summary>
            Deserialize a json array as an IEnumerable of BsonValue reading on demand TextReader
            </summary>
        </member>
        <member name="T:LiteDB.ObjectId">
            <summary>
            Represent a 12-bytes BSON type used in document Id
            </summary>
        </member>
        <member name="P:LiteDB.ObjectId.Empty">
            <summary>
            A zero 12-bytes ObjectId
            </summary>
        </member>
        <member name="P:LiteDB.ObjectId.Timestamp">
            <summary>
            Get timestamp
            </summary>
        </member>
        <member name="P:LiteDB.ObjectId.Machine">
            <summary>
            Get machine number
            </summary>
        </member>
        <member name="P:LiteDB.ObjectId.Pid">
            <summary>
            Get pid number
            </summary>
        </member>
        <member name="P:LiteDB.ObjectId.Increment">
            <summary>
            Get increment
            </summary>
        </member>
        <member name="P:LiteDB.ObjectId.CreationTime">
            <summary>
            Get creation time
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.#ctor">
            <summary>
            Initializes a new empty instance of the ObjectId class.
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.#ctor(System.Int32,System.Int32,System.Int16,System.Int32)">
            <summary>
            Initializes a new instance of the ObjectId class from ObjectId vars.
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.#ctor(LiteDB.ObjectId)">
            <summary>
            Initializes a new instance of ObjectId class from another ObjectId.
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.#ctor(System.String)">
            <summary>
            Initializes a new instance of the ObjectId class from hex string.
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.#ctor(System.Byte[])">
            <summary>
            Initializes a new instance of the ObjectId class from byte array.
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.FromHex(System.String)">
            <summary>
            Convert hex value string in byte array
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.Equals(LiteDB.ObjectId)">
            <summary>
            Checks if this ObjectId is equal to the given object. Returns true
            if the given object is equal to the value of this instance. 
            Returns false otherwise.
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.Equals(System.Object)">
            <summary>
            Determines whether the specified object is equal to this instance.
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.GetHashCode">
            <summary>
            Returns a hash code for this instance.
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.CompareTo(LiteDB.ObjectId)">
            <summary>
            Compares two instances of ObjectId
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.ToByteArray">
            <summary>
            Represent ObjectId as 12 bytes array
            </summary>
        </member>
        <member name="M:LiteDB.ObjectId.NewObjectId">
            <summary>
            Creates a new ObjectId.
            </summary>
        </member>
        <member name="T:LiteDB.Engine.EngineSettings">
            <summary>
            All engine settings used to starts new engine
            </summary>
        </member>
        <member name="P:LiteDB.Engine.EngineSettings.DataStream">
            <summary>
            Get/Set custom stream to be used as datafile (can be MemoryStrem or TempStream). Do not use FileStream - to use physical file, use "filename" attribute (and keep DataStrem/WalStream null)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.EngineSettings.WalStream">
            <summary>
            Get/Set custom stream to be used as walfile. If is null, use a new TempStream (for TempStrem datafile) or MemoryStrema (for MemoryStream datafile)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.EngineSettings.Log">
            <summary>
            Get/Set custom instance for Logger
            </summary>
        </member>
        <member name="P:LiteDB.Engine.EngineSettings.Filename">
            <summary>
            Full path or relative path from DLL directory. Can use ':temp:' for temp database or ':memory:' for in-memory database. (default: ':memory:')
            </summary>
        </member>
        <member name="P:LiteDB.Engine.EngineSettings.Timeout">
            <summary>
            Timeout for waiting unlock operations (default: 1 minute)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.EngineSettings.InitialSize">
            <summary>
            If database is new, initialize with allocated space (in bytes) (default: 0)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.EngineSettings.LimitSize">
            <summary>
            Max limit of datafile (in bytes) (default: MaxValue)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.EngineSettings.LogLevel">
            <summary>
            Debug messages from database - (default: Logger.NONE)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.EngineSettings.UtcDate">
            <summary>
            Returns date in UTC timezone from BSON deserialization (default: false == LocalTime)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.EngineSettings.Checkpoint">
            <summary>
            When wal file get this checkpoint limit, write over data disk
            </summary>
        </member>
        <member name="P:LiteDB.Engine.EngineSettings.CheckpointOnShutdown">
            <summary>
            Indicate that engine will do a checkpoint on dispose database
            </summary>
        </member>
        <member name="P:LiteDB.Engine.EngineSettings.MaxMemoryTransactionSize">
            <summary>
            Define max pages a trasaction must keep in-memory before flush to WAL file. Must be larger than 100 (default 1000)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.EngineSettings.GetDiskFactory">
            <summary>
            Get datafile factory
            </summary>
        </member>
        <member name="T:LiteDB.Engine.LiteEngine">
            <summary>
            A public class that take care of all engine data structure access - its basic implementation of a NoSql database
            Its isolated from complete solution - works on low level only (no linq, no poco... just Bson objects)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.Analyze(System.String[])">
            <summary>
            Analyze collection indexes to update UniqueKey counter. If collections parameter are null, analyze all collections
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.GetCollectionNames">
            <summary>
            Returns all collection inside datafile
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.DropCollection(System.String)">
            <summary>
            Drop collection including all documents, indexes and extended pages (do not support transactions)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.RenameCollection(System.String,System.String)">
            <summary>
            Rename a collection (do not support transactions)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.Delete(System.String,System.Collections.Generic.IEnumerable{LiteDB.BsonValue})">
            <summary>
            Implements delete based on IDs enumerable
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.DeleteMany(System.String,LiteDB.BsonExpression)">
            <summary>
            Implements delete based on filter expression
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.Execute(System.String,LiteDB.BsonDocument)">
            <summary>
            Execute single SQL-Like command and return data reader (can contains single or multiple resultsets). 
            Will execute only first command. Need NextResult() called to run anothers commands
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.EnsureIndex(System.String,System.String,LiteDB.BsonExpression,System.Boolean)">
            <summary>
            Create a new index (or do nothing if already exists) to a collection/field
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.DropIndex(System.String,System.String)">
            <summary>
            Drop an index from a collection
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.Insert(System.String,System.Collections.Generic.IEnumerable{LiteDB.BsonDocument},LiteDB.BsonAutoId)">
            <summary>
            Insert all documents in collection. If document has no _id, use AutoId generation.
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.InsertDocument(LiteDB.Engine.Snapshot,LiteDB.Engine.CollectionPage,LiteDB.BsonDocument,LiteDB.BsonAutoId,LiteDB.Engine.IndexService,LiteDB.Engine.DataService)">
            <summary>
            Internal implementation of insert a document
            </summary>
        </member>
        <member name="F:LiteDB.Engine.LiteEngine._sequences">
            <summary>
            Collection last sequence cache
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.GetSequence(LiteDB.Engine.CollectionPage,LiteDB.Engine.Snapshot,LiteDB.BsonAutoId)">
            <summary>
            Get lastest value from a _id collection and plus 1 - use _sequence cache
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.SetSequence(LiteDB.Engine.CollectionPage,LiteDB.Engine.Snapshot,LiteDB.BsonValue)">
            <summary>
            Update sequence number with new _id passed by user, IF this number are higher than current last _id
            At this point, newId.Type is Number
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.GetLastId(LiteDB.Engine.CollectionPage,LiteDB.Engine.Snapshot)">
            <summary>
            Get last _id index key from collection. Returns MinValue if collection are empty
            </summary>
        </member>
        <member name="F:LiteDB.Engine.LiteEngine._cursors">
            <summary>
            Store all cursor information
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.Query(System.String,LiteDB.Engine.QueryDefinition)">
            <summary>
            Run query over collection using a query definition
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.NewCursor(LiteDB.Engine.TransactionService,LiteDB.Engine.Snapshot)">
            <summary>
            Create new cursor instance and add to cursor log. Start cursor timer
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.Shrink">
            <summary>
            Reduce disk size re-arranging unused spaces.
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.Shrink(LiteDB.Engine.IFileReader)">
            <summary>
            Run shrink operation using an file reader interface (can be used as Upgrade datafile)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.GetSystemCollection(System.String)">
            <summary>
            Get registered system collection
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.RegisterSystemCollection(LiteDB.Engine.SystemCollection)">
            <summary>
            Register a new system collection that can be used in query for input/output data
            Collection name must starts with $
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.RegisterSystemCollection(System.String,System.Func{System.Collections.Generic.IEnumerable{LiteDB.BsonDocument}})">
            <summary>
            Register a new system collection that can be used in query for input data
            Collection name must starts with $
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.BeginTrans">
            <summary>
            Initialize a new transaction. Transaction are created "per-thread". There is only one single transaction per thread.
            Return true if transaction was created or false if current thread already in a transaction.
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.Commit">
            <summary>
            Persist all dirty pages into WAL file using async task. 
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.Rollback">
            <summary>
            Do rollback to current transaction. Clear dirty pages in memory and return new pages to main empty linked-list
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.AutoTransaction``1(System.Func{LiteDB.Engine.TransactionService,``0})">
            <summary>
            Create (or reuse) a transaction an add try/catch block. Commit transaction if is new transaction
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.Update(System.String,System.Collections.Generic.IEnumerable{LiteDB.BsonDocument})">
            <summary>
            Implement update command to a document inside a collection. Return number of documents updated
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.UpdateMany(System.String,LiteDB.BsonExpression,LiteDB.BsonExpression)">
            <summary>
            Update documents using extend expression to extend found document using predicate
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.UpdateDocument(LiteDB.Engine.Snapshot,LiteDB.Engine.CollectionPage,LiteDB.BsonDocument,LiteDB.Engine.IndexService,LiteDB.Engine.DataService)">
            <summary>
            Implement internal update document
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.Upgrade">
            <summary>
            Upgrade datafile from old versions - use same process as Shrink: use new engine with same WAL filename and checkpoint over same datafile
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.Upsert(System.String,System.Collections.Generic.IEnumerable{LiteDB.BsonDocument},LiteDB.BsonAutoId)">
            <summary>
            Implement upsert command to documents in a collection. Calls update on all documents,
            then any documents not updated are then attempted to insert.
            This will have the side effect of throwing if duplicate items are attempted to be inserted.
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.GetUserVersion">
            <summary>
            Get database user version. If set new value, requires no current transaction
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.SetUserVersion(System.Int32)">
            <summary>
            Set new database user version. Requires no transaction at this time
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.Vaccum">
            <summary>
            Read database searching for empty pages but non-linked in FreeListPage. Must run Checkpoint before and do lock reserved
            Runs only in with no current transaction
            Returns how many pages was mark as deleted page
            </summary>
        </member>
        <member name="P:LiteDB.Engine.LiteEngine.TempDB">
            <summary>
            Get/Set temporary engine database used to sort data
            </summary>
        </member>
        <member name="P:LiteDB.Engine.LiteEngine.UtcDate">
            <summary>
            Get if date must be read from Bson as UTC date 
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.#ctor">
            <summary>
            Initialize LiteEngine using connection memory database
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.#ctor(System.String)">
            <summary>
            Initialize LiteEngine using connection string using key=value; parser
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.#ctor(LiteDB.Engine.IEngineSettings)">
            <summary>
            Initialize LiteEngine using initial engine settings
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.Checkpoint(System.Boolean)">
            <summary>
            Request a WAL checkpoint
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.Dispose">
            <summary>
            Shutdown database
            - After dispose engine, no more new transaction
            - All transation will throw shutdown exception and do rollback
            - Wait for async write with full flush to disk
            - Do checkpoint (sync)
            - Dispose disks
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.InitializeSystemCollections">
            <summary>
            Register all internal system collections avaiable by default
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LiteEngine.DumpPage(LiteDB.Engine.BasePage,System.Nullable{System.Int64},System.Nullable{System.Int32},System.Boolean,System.Collections.Generic.Dictionary{System.UInt32,System.String})">
            <summary>
            Dump page information into a BsonDocument
            </summary>
        </member>
        <member name="T:LiteDB.Engine.FileReaderV7">
            <summary>
            Internal class to read old LiteDB v4 database version (datafile v7 structure)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.FileReaderV7.GetCollections">
            <summary>
            Read all collection based on header page
            </summary>
        </member>
        <member name="M:LiteDB.Engine.FileReaderV7.GetIndexes">
            <summary>
            Read all indexes from all collection pages
            </summary>
        </member>
        <member name="M:LiteDB.Engine.FileReaderV7.GetDocuments(LiteDB.Engine.IndexInfo)">
            <summary>
            Get all document using an indexInfo as start point (_id index).
            </summary>
        </member>
        <member name="M:LiteDB.Engine.FileReaderV7.ReadPage(System.UInt32)">
            <summary>
            Read all database pages from v7 structure into a flexible BsonDocument - only read what really needs
            </summary>
        </member>
        <member name="M:LiteDB.Engine.FileReaderV7.ReadExtendData(System.UInt32)">
            <summary>
            Read extend data block
            </summary>
        </member>
        <member name="T:LiteDB.Engine.FileReaderV8">
            <summary>
            Internal class to read all datafile documents - use simplest way using current engine
            </summary>
        </member>
        <member name="M:LiteDB.Engine.FileReaderV8.GetCollections">
            <summary>
            Read all collection based on header page
            </summary>
        </member>
        <member name="M:LiteDB.Engine.FileReaderV8.GetIndexes">
            <summary>
            Read all indexes from all collection pages
            </summary>
        </member>
        <member name="M:LiteDB.Engine.FileReaderV8.GetDocuments(LiteDB.Engine.IndexInfo)">
            <summary>
            Read all document based on collection name
            </summary>
        </member>
        <member name="T:LiteDB.Engine.IFileReader">
            <summary>
            Interface to read current or old datafile structure - Used to shirnk/upgrade datafile from old LiteDB versions
            </summary>
        </member>
        <member name="F:LiteDB.Engine.BasePage._zeroBuffer">
            <summary>
            Create a re-usable buffer with zero value
            </summary>
        </member>
        <member name="P:LiteDB.Engine.BasePage.PageID">
            <summary>
            Represent page number - start in 0 with HeaderPage [4 bytes]
            </summary>
        </member>
        <member name="P:LiteDB.Engine.BasePage.PageType">
            <summary>
            Indicate the page type [1 byte] - Must be implemented for each page type
            </summary>
        </member>
        <member name="P:LiteDB.Engine.BasePage.PrevPageID">
            <summary>
            Represent the previous page. Used for page-sequences - MaxValue represent that has NO previous page [4 bytes]
            </summary>
        </member>
        <member name="P:LiteDB.Engine.BasePage.NextPageID">
            <summary>
            Represent the next page. Used for page-sequences - MaxValue represent that has NO next page [4 bytes]
            </summary>
        </member>
        <member name="P:LiteDB.Engine.BasePage.ItemCount">
            <summary>
            Used for all pages to count items inside this page(bytes, nodes, blocks, ...) [2 bytes]
            Its Int32 but writes in UInt16
            </summary>
        </member>
        <member name="P:LiteDB.Engine.BasePage.FreeBytes">
            <summary>
            Used to find a free page using only header search [used in FreeList] [2 bytes]
            Its Int32 but writes in UInt16
            Its updated when a page modify content length (add/remove items)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.BasePage.ColID">
            <summary>
            Set in all datafile pages the page id about data/index collection. Useful if want re-build database without any index
            </summary>
        </member>
        <member name="P:LiteDB.Engine.BasePage.TransactionID">
            <summary>
            Represent transaction page ID that was stored [16 bytes]
            </summary>
        </member>
        <member name="P:LiteDB.Engine.BasePage.IsConfirmed">
            <summary>
            Used in WAL, define this page is last transaction page and are confirmed on disk [1 byte]
            </summary>
        </member>
        <member name="P:LiteDB.Engine.BasePage.IsDirty">
            <summary>
            Set this pages that was changed and must be persist in disk [not peristable]
            </summary>
        </member>
        <member name="M:LiteDB.Engine.BasePage.WritePage(System.IO.BinaryWriter)">
            <summary>
            Write a page to byte array
            </summary>
        </member>
        <member name="M:LiteDB.Engine.BasePage.GetPagePosition(System.UInt32)">
            <summary>
            Returns a size of specified number of pages
            </summary>
        </member>
        <member name="M:LiteDB.Engine.BasePage.GetPagePosition(System.Int32)">
            <summary>
            Returns a size of specified number of pages
            </summary>
        </member>
        <member name="M:LiteDB.Engine.BasePage.CreateInstance``1(System.UInt32)">
            <summary>
            Create a new instance of page based on T type
            </summary>
        </member>
        <member name="M:LiteDB.Engine.BasePage.CreateInstance(System.UInt32,LiteDB.Engine.PageType)">
            <summary>
            Create a new instance of page based on PageType
            </summary>
        </member>
        <member name="M:LiteDB.Engine.BasePage.ReadPage(System.IO.BinaryReader,System.Boolean,System.Boolean)">
            <summary>
            Read a page with correct instance page object. Checks for pageType
            </summary>
        </member>
        <member name="T:LiteDB.Engine.CollectionPage">
            <summary>
            Represents the collection page AND a collection item, because CollectionPage represent a Collection (1 page = 1 collection). All collections pages are linked with Prev/Next links
            </summary>
        </member>
        <member name="F:LiteDB.Engine.CollectionPage.INDEX_PAGE_FIXED_HEADER">
            <summary>
            Define reserved bytes for data structure
            </summary>
        </member>
        <member name="F:LiteDB.Engine.CollectionPage.MAX_INDEX_NAME_SIZE">
            <summary>
            Max length of all indexes names (including string expressions)
            </summary>
        </member>
        <member name="F:LiteDB.Engine.CollectionPage.FIXED_INDEX_SIZE">
            <summary>
            Each index fixed size
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CollectionPage.PageType">
            <summary>
            Page type = Collection
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CollectionPage.CollectionName">
            <summary>
            Name of collection
            </summary>
        </member>
        <member name="F:LiteDB.Engine.CollectionPage.FreeDataPageID">
            <summary>
            Get a reference for the free list data page - its private list per collection - each DataPage contains only data for 1 collection (no mixing)
            Must to be a Field to be used as parameter reference
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CollectionPage.CreationTime">
            <summary>
            DateTime when collection was created
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CollectionPage.LastAnalyzed">
            <summary>
            DateTime from last index counter
            </summary>
        </member>
        <member name="F:LiteDB.Engine.CollectionPage._indexes">
            <summary>
            Get all indexes from this collection - includes non-used indexes
            </summary>
        </member>
        <member name="M:LiteDB.Engine.CollectionPage.GetFreeIndex">
            <summary>
            Returns first free index slot to be used
            </summary>
        </member>
        <member name="M:LiteDB.Engine.CollectionPage.GetIndex(System.String)">
            <summary>
            Get index from index name (index name is case sensitive) - returns null if not found
            </summary>
        </member>
        <member name="M:LiteDB.Engine.CollectionPage.GetIndex(System.Int32)">
            <summary>
            Get index from index slot
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CollectionPage.PK">
            <summary>
            Get primary key index (_id index)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.CollectionPage.GetIndexes(System.Boolean)">
            <summary>
            Returns all used indexes
            </summary>
        </member>
        <member name="M:LiteDB.Engine.CollectionPage.CalculateNameSize">
            <summary>
            Calculate if all indexes names and expressions fit on this page
            </summary>
        </member>
        <member name="T:LiteDB.Engine.DataPage">
            <summary>
            The DataPage thats stores object data.
            </summary>
        </member>
        <member name="P:LiteDB.Engine.DataPage.PageType">
            <summary>
            Page type = Extend
            </summary>
        </member>
        <member name="F:LiteDB.Engine.DataPage._dataBlocks">
            <summary>
            Returns all data blocks - Each block has one object
            </summary>
        </member>
        <member name="M:LiteDB.Engine.DataPage.GetBlock(System.UInt16)">
            <summary>
            Get datablock from internal blocks collection
            </summary>
        </member>
        <member name="M:LiteDB.Engine.DataPage.AddBlock(LiteDB.Engine.DataBlock)">
            <summary>
            Add new data block into this page, update counter + free space
            </summary>
        </member>
        <member name="M:LiteDB.Engine.DataPage.UpdateBlockData(LiteDB.Engine.DataBlock,System.Byte[])">
            <summary>
            Update byte array from existing data block. Update free space too
            </summary>
        </member>
        <member name="M:LiteDB.Engine.DataPage.DeleteBlock(LiteDB.Engine.DataBlock)">
            <summary>
            Remove data block from this page. Update counters and free space
            </summary>
        </member>
        <member name="P:LiteDB.Engine.DataPage.BlocksCount">
            <summary>
            Get block counter from this page
            </summary>
        </member>
        <member name="T:LiteDB.Engine.EmptyPage">
            <summary>
            Represent a empty page (reused)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.EmptyPage.PageType">
            <summary>
            Page type = Empty
            </summary>
        </member>
        <member name="T:LiteDB.Engine.ExtendPage">
            <summary>
            Represent a extra data page that contains the object when is not possible store in DataPage (bigger then  PAGE_SIZE or on update has no more space on page)
            Can be used in sequence of pages to store big objects
            </summary>
        </member>
        <member name="P:LiteDB.Engine.ExtendPage.PageType">
            <summary>
            Page type = Extend
            </summary>
        </member>
        <member name="F:LiteDB.Engine.ExtendPage._data">
            <summary>
            Represent the part or full of the object - if this page has NextPageID the object is bigger than this page
            </summary>
        </member>
        <member name="M:LiteDB.Engine.ExtendPage.SetData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Set slice of byte array source  into this page area
            </summary>
        </member>
        <member name="M:LiteDB.Engine.ExtendPage.GetData">
            <summary>
            Get internal page byte array data
            </summary>
        </member>
        <member name="P:LiteDB.Engine.HeaderPage.PageType">
            <summary>
            Page type = Header
            </summary>
        </member>
        <member name="F:LiteDB.Engine.HeaderPage.HEADER_INFO">
            <summary>
            Header info the validate that datafile is a LiteDB file (27 bytes)
            </summary>
        </member>
        <member name="F:LiteDB.Engine.HeaderPage.FILE_VERSION">
            <summary>
            Datafile specification version
            </summary>
        </member>
        <member name="F:LiteDB.Engine.HeaderPage.FreeEmptyPageID">
            <summary>
            Get/Set the pageID that start sequence with a complete empty pages (can be used as a new page) [4 bytes]
            </summary>
        </member>
        <member name="F:LiteDB.Engine.HeaderPage.LastPageID">
            <summary>
            Last created page - Used when there is no free page inside file [4 bytes]
            </summary>
        </member>
        <member name="P:LiteDB.Engine.HeaderPage.CreationTime">
            <summary>
            DateTime when database was created [8 bytes]
            </summary>
        </member>
        <member name="P:LiteDB.Engine.HeaderPage.LastCheckpoint">
            <summary>
            DateTime when database run checkpoint [8 bytes]
            </summary>
        </member>
        <member name="P:LiteDB.Engine.HeaderPage.UserVersion">
            <summary>
            UserVersion int - for user get/set database version changes
            </summary>
        </member>
        <member name="P:LiteDB.Engine.HeaderPage.FileVersion">
            <summary>
            Get data strcuture file version. If not equals to FILE_VERSION const (8) must be upgrade 
            </summary>
        </member>
        <member name="P:LiteDB.Engine.HeaderPage.Collections">
            <summary>
            Contains all collection in database using PageID to direct access
            </summary>
        </member>
        <member name="M:LiteDB.Engine.HeaderPage.UpdateCollections(LiteDB.Engine.TransactionPages)">
            <summary>
            Update header page with new/drop collections
            </summary>
        </member>
        <member name="M:LiteDB.Engine.HeaderPage.CheckCollectionsSize(System.String)">
            <summary>
            Check if all new collection names fit on header page with all existing collection
            </summary>
        </member>
        <member name="P:LiteDB.Engine.IndexPage.PageType">
            <summary>
            Page type = Index
            </summary>
        </member>
        <member name="M:LiteDB.Engine.IndexPage.GetNode(System.UInt16)">
            <summary>
            Get an index node from this page
            </summary>
        </member>
        <member name="M:LiteDB.Engine.IndexPage.AddNode(LiteDB.Engine.IndexNode)">
            <summary>
            Add new index node into this page. Update counters and free space
            </summary>
        </member>
        <member name="M:LiteDB.Engine.IndexPage.DeleteNode(LiteDB.Engine.IndexNode)">
            <summary>
            Delete node from this page and update counter and free space
            </summary>
        </member>
        <member name="P:LiteDB.Engine.IndexPage.NodesCount">
            <summary>
            Get node counter
            </summary>
        </member>
        <member name="T:LiteDB.Engine.Index">
            <summary>
            Class that implement higher level of index search operations (equals, greater, less, ...)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.Index.Name">
            <summary>
            Index name
            </summary>
        </member>
        <member name="P:LiteDB.Engine.Index.Order">
            <summary>
            Get/Set index order
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Index.All(System.Int32)">
            <summary>
            Returns all documents using _id index order
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Index.All(System.String,System.Int32)">
            <summary>
            Returns all documents using index order
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Index.EQ(System.String,LiteDB.BsonValue)">
            <summary>
            Returns all documents that value are equals to value (=)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Index.LT(System.String,LiteDB.BsonValue,System.Int32)">
            <summary>
            Returns all documents that value are less than value (&lt;)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Index.LTE(System.String,LiteDB.BsonValue,System.Int32)">
            <summary>
            Returns all documents that value are less than or equals value (&lt;=)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Index.GT(System.String,LiteDB.BsonValue,System.Int32)">
            <summary>
            Returns all document that value are greater than value (&gt;)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Index.GTE(System.String,LiteDB.BsonValue,System.Int32)">
            <summary>
            Returns all documents that value are greater than or equals value (&gt;=)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Index.Between(System.String,LiteDB.BsonValue,LiteDB.BsonValue,System.Int32)">
            <summary>
            Returns all document that values are between "start" and "end" values (BETWEEN)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Index.Like(System.String,System.String,System.Int32)">
            <summary>
            Returns all documents that "Sql Like" with value
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Index.StartsWith(System.String,System.String,System.Int32)">
            <summary>
            Returns all documents that startsWith value [index scan]
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Index.Scan(System.String,System.Func{LiteDB.BsonValue,System.Boolean},System.Int32)">
            <summary>
            Apply a predicate function in an index result (index scan). Execute full index scan but it's faster then runs over deserialized document.
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Index.Contains(System.String,System.String,System.Int32)">
            <summary>
            Returns all documents that contains value [index scan]
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Index.EndsWith(System.String,System.String,System.Int32)">
            <summary>
            Returns all documents that ends with string [index scan]
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Index.Not(System.String,LiteDB.BsonValue,System.Int32)">
            <summary>
            Returns all documents that are not equals to value (not equals) [index scan]
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Index.In(System.String,LiteDB.BsonArray,System.Int32)">
            <summary>
            Returns all documents that are equals with any item in array (IN)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Index.GetCost(LiteDB.Engine.CollectionIndex)">
            <summary>
            Calculate cost based on type/value/collection - From 1 (best) to Collection.KeyCount (worst)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Index.Execute(LiteDB.Engine.IndexService,LiteDB.Engine.CollectionIndex)">
            <summary>
            Abstract method that must be implement for index seek/scan - Returns IndexNodes that match with index
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Index.Run(LiteDB.Engine.CollectionPage,LiteDB.Engine.IndexService)">
            <summary>
            Find witch index will be used and run Execute method
            </summary>
        </member>
        <member name="T:LiteDB.Engine.IndexAll">
            <summary>
            Return all index nodes
            </summary>
        </member>
        <member name="T:LiteDB.Engine.IndexEquals">
            <summary>
            Implement equals index operation =
            </summary>
        </member>
        <member name="T:LiteDB.Engine.IndexIn">
            <summary>
            Implement IN index operation. Value must be an array
            </summary>
        </member>
        <member name="T:LiteDB.Engine.IndexRange">
            <summary>
            Implement range operation - in asc or desc way - can be used as LT, LTE, GT, GTE too because support MinValue/MaxValue
            </summary>
        </member>
        <member name="T:LiteDB.Engine.IndexScan">
            <summary>
            Execute an "index scan" passing a Func as where
            </summary>
        </member>
        <member name="T:LiteDB.Engine.IndexVirtual">
            <summary>
            Implement virtual index for system collections
            </summary>
        </member>
        <member name="M:LiteDB.Engine.IndexVirtual.CreateCollectionPage(System.String)">
            <summary>
            Create fake collection page for virtual collections
            </summary>
        </member>
        <member name="T:LiteDB.Engine.CachedDocumentLoader">
            <summary>
            Same as DocumentLoad, but with cache to re-use same document if already loaded (with limit size)
            </summary>
        </member>
        <member name="T:LiteDB.Engine.DocumentLoader">
            <summary>
            Implement basic document loader based on data service/bson reader
            </summary>
        </member>
        <member name="T:LiteDB.Engine.IDocumentLoader">
            <summary>
            Interface for abstract document loader that can be direct from datafile or by virtual collections
            </summary>
        </member>
        <member name="T:LiteDB.Engine.IndexKeyLoader">
            <summary>
            Implement loader based only in index Key
            </summary>
        </member>
        <member name="T:LiteDB.Engine.BasePipe">
            <summary>
            Abstract class with workflow method to be used in pipeline implementation
            </summary>
        </member>
        <member name="M:LiteDB.Engine.BasePipe.Pipe(System.Collections.Generic.IEnumerable{LiteDB.Engine.IndexNode},LiteDB.Engine.QueryPlan)">
            <summary>
            Abstract method to be implement according pipe workflow
            </summary>
        </member>
        <member name="M:LiteDB.Engine.BasePipe.Include(System.Collections.Generic.IEnumerable{LiteDB.BsonDocument},LiteDB.BsonExpression)">
            <summary>
            Pipe: Do include in result document according path expression
            </summary>
        </member>
        <member name="M:LiteDB.Engine.BasePipe.Filter(System.Collections.Generic.IEnumerable{LiteDB.BsonDocument},LiteDB.BsonExpression)">
            <summary>
            Pipe: Filter document according expression. Expression must be an Bool result
            </summary>
        </member>
        <member name="M:LiteDB.Engine.BasePipe.OrderBy(System.Collections.Generic.IEnumerable{LiteDB.BsonDocument},LiteDB.BsonExpression,System.Int32,System.Int32,System.Int32)">
            <summary>
            Pipe: OrderBy documents according orderby expression/order
            </summary>
        </member>
        <member name="T:LiteDB.Engine.DocumentEnumerable">
            <summary>
            Implement an IEnumerable document cache that read data first time and store in memory/disk cache
            Used in GroupBy operation and MUST read all IEnumerable source before dispose because are need be linear from main resultset
            </summary>
        </member>
        <member name="T:LiteDB.Engine.GroupByPipe">
            <summary>
            Implement query using GroupBy expression
            </summary>
        </member>
        <member name="M:LiteDB.Engine.GroupByPipe.GroupBy(System.Collections.Generic.IEnumerable{LiteDB.BsonDocument},LiteDB.BsonExpression)">
            <summary>
            Apply groupBy expression and transform results
            </summary>
        </member>
        <member name="M:LiteDB.Engine.GroupByPipe.SelectGroupBy(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{LiteDB.BsonDocument}},LiteDB.BsonExpression)">
            <summary>
            Transform groups of documents into single documents enumerable and apply select expression into group or return first document from each group
            </summary>
        </member>
        <member name="M:LiteDB.Engine.GroupByPipe.Having(System.Collections.Generic.IEnumerable{LiteDB.BsonDocument},LiteDB.BsonExpression)">
            <summary>
            Pipe: Filter source using having bool expression to skip or include on final resultset
            </summary>
        </member>
        <member name="T:LiteDB.Engine.GroupByPipe.Done">
            <summary>
            Bool inside a class to be used as "ref" parameter on ienumerable
            </summary>
        </member>
        <member name="T:LiteDB.Engine.QueryPipe">
            <summary>
            Basic query pipe workflow - support filter, includes and orderby
            </summary>
        </member>
        <member name="M:LiteDB.Engine.QueryPipe.Select(System.Collections.Generic.IEnumerable{LiteDB.BsonDocument},LiteDB.BsonExpression)">
            <summary>
            Pipe: Transaform final result appling expressin transform. Can return document or simple values
            </summary>
        </member>
        <member name="T:LiteDB.Engine.QueryExecutor">
            <summary>
            Class that execute QueryPlan returing results
            </summary>
        </member>
        <member name="M:LiteDB.Engine.QueryExecutor.ExecuteQuery(System.Boolean)">
            <summary>
            Run query definition into engine. Execute optimization to get query planner
            </summary>
        </member>
        <member name="M:LiteDB.Engine.QueryExecutor.ExecuteQueryInto(System.String,LiteDB.BsonAutoId)">
            <summary>
            Execute query and insert result into another collection. Support external collections
            </summary>
        </member>
        <member name="T:LiteDB.Engine.QueryOptimization">
            <summary>
            Class that optimize query transforming QueryDefinition into QueryPlan
            </summary>
        </member>
        <member name="M:LiteDB.Engine.QueryOptimization.ProcessQuery">
            <summary>
            Build QueryPlan instance based on QueryBuilder fields
            - Load used fields in all expressions
            - Select best index option
            - Fill includes 
            - Define orderBy
            - Define groupBy
            </summary>
        </member>
        <member name="M:LiteDB.Engine.QueryOptimization.SplitWherePredicateInTerms">
            <summary>
            Fill terms from where predicate list
            </summary>
        </member>
        <member name="M:LiteDB.Engine.QueryOptimization.DefineQueryFields">
            <summary>
            Load all fields that must be deserialize from document.
            </summary>
        </member>
        <member name="M:LiteDB.Engine.QueryOptimization.ChooseIndex(System.Collections.Generic.HashSet{System.String})">
            <summary>
            Try select best index (lowest cost) to this list of where expressions
            </summary>
        </member>
        <member name="M:LiteDB.Engine.QueryOptimization.DefineOrderBy">
            <summary>
            Define OrderBy optimization (try re-use index)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.QueryOptimization.DefineGroupBy">
            <summary>
            Define GroupBy optimization (try re-use index)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.QueryOptimization.DefineIncludes">
            <summary>
            Will define each include to be run BEFORE where (worst) OR AFTER where (best)
            </summary>
        </member>
        <member name="T:LiteDB.Engine.CursorInfo">
            <summary>
            Store information about a single cursor running on query builder. Used in $open_cursors collection
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CursorInfo.CursorID">
            <summary>
            Get sequencial cursor ID
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CursorInfo.TransactionID">
            <summary>
            Get transaction ID
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CursorInfo.ReadVersion">
            <summary>
            Get snapshot read version
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CursorInfo.CollectionName">
            <summary>
            Get collection name
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CursorInfo.Mode">
            <summary>
            Get is collection are read/write lock mode
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CursorInfo.Timer">
            <summary>
            Count time for run query
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CursorInfo.DocumentLoad">
            <summary>
            Get how many document query pipe read from disk/cache
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CursorInfo.DocumentCount">
            <summary>
            Get how many documents returns on query
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CursorInfo.Done">
            <summary>
            Get/Set if current cursor are done (read all data)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.CursorInfo.Start">
            <summary>
            Start timer
            </summary>
        </member>
        <member name="M:LiteDB.Engine.CursorInfo.Finish">
            <summary>
            Finish query results
            </summary>
        </member>
        <member name="M:LiteDB.Engine.CursorInfo.Pause">
            <summary>
            Pause timer (to return to use document)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.CursorInfo.Resume">
            <summary>
            Re-start timer
            </summary>
        </member>
        <member name="T:LiteDB.Engine.GroupBy">
            <summary>
            Represent an GroupBy definition (is based on OrderByDefinition)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.GroupBy.Select">
            <summary>
            Get/Set transform expression in group by
            </summary>
        </member>
        <member name="P:LiteDB.Engine.GroupBy.Having">
            <summary>
            Get/Set if have filter after group by
            </summary>
        </member>
        <member name="T:LiteDB.Engine.IndexCost">
            <summary>
            Calculate index cost based on expression/collection index. 
            Lower cost is better - lowest will be selected
            </summary>
        </member>
        <member name="P:LiteDB.Engine.IndexCost.Expression">
            <summary>
            Get filtered expression: "$._id = 10"
            </summary>
        </member>
        <member name="P:LiteDB.Engine.IndexCost.IndexExpression">
            <summary>
            Get index expression only: "$._id"
            </summary>
        </member>
        <member name="P:LiteDB.Engine.IndexCost.Index">
            <summary>
            Get created Index instance used on query
            </summary>
        </member>
        <member name="M:LiteDB.Engine.IndexCost.CreateIndex(LiteDB.BsonExpressionType,System.String,LiteDB.BsonValue)">
            <summary>
            Create index based on expression predicate
            </summary>
        </member>
        <member name="T:LiteDB.Engine.OrderBy">
            <summary>
            Represent an OrderBy definition
            </summary>
        </member>
        <member name="T:LiteDB.Engine.QueryPlan">
            <summary>
            This class are result from optimization from QueryBuild in QueryAnalyzer. Indicate how engine must run query - there is no more decisions to engine made, must only execute as query was defined
            Contains used index and estimate cost to run
            </summary>
        </member>
        <member name="P:LiteDB.Engine.QueryPlan.Collection">
            <summary>
            Get collection name (required)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.QueryPlan.Index">
            <summary>
            Index used on query (required)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.QueryPlan.IndexExpression">
            <summary>
            Index expression that will be used in index (source only)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.QueryPlan.IndexCost">
            <summary>
            Get index cost (lower is best)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.QueryPlan.IsIndexKeyOnly">
            <summary>
            If true, gereate document result only with IndexNode.Key (avoid load all document)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.QueryPlan.Filters">
            <summary>
            List of filters of documents
            </summary>
        </member>
        <member name="P:LiteDB.Engine.QueryPlan.IncludeBefore">
            <summary>
            List of includes must be done BEFORE filter (it's not optimized but some filter will use this include)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.QueryPlan.IncludeAfter">
            <summary>
            List of includes must be done AFTER filter (it's optimized because will include result only)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.QueryPlan.OrderBy">
            <summary>
            Expression to order by resultset
            </summary>
        </member>
        <member name="P:LiteDB.Engine.QueryPlan.GroupBy">
            <summary>
            Expression to group by document results
            </summary>
        </member>
        <member name="P:LiteDB.Engine.QueryPlan.Select">
            <summary>
            Transaformation data before return - if null there is no transform (return document)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.QueryPlan.Fields">
            <summary>
            Get fields name that will be deserialize from disk
            </summary>
        </member>
        <member name="P:LiteDB.Engine.QueryPlan.Limit">
            <summary>
            Limit resultset
            </summary>
        </member>
        <member name="P:LiteDB.Engine.QueryPlan.Offset">
            <summary>
            Skip documents before returns
            </summary>
        </member>
        <member name="P:LiteDB.Engine.QueryPlan.ForUpdate">
            <summary>
            Indicate this query is for update (lock mode = Write)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.QueryPlan.GetExecutionPlan">
            <summary>
            Get detail about execution plan for this query definition
            </summary>
        </member>
        <member name="T:LiteDB.Engine.Select">
            <summary>
            Represent a Select expression
            </summary>
        </member>
        <member name="M:LiteDB.Engine.CollectionService.Get(System.String)">
            <summary>
            Get a exist collection in header or in current transaction. Returns null if not exists
            </summary>
        </member>
        <member name="M:LiteDB.Engine.CollectionService.Add(System.String)">
            <summary>
            Add a new collection. Check if name the not exists. Create only in transaction page - will update header only in commit
            </summary>
        </member>
        <member name="M:LiteDB.Engine.CollectionService.GetAll">
            <summary>
            Get all collections pages
            </summary>
        </member>
        <member name="M:LiteDB.Engine.CollectionService.Drop(LiteDB.Engine.CollectionPage,LiteDB.Engine.TransactionService)">
            <summary>
            Drop a collection - remove all data pages + indexes pages
            </summary>
        </member>
        <member name="T:LiteDB.Engine.DataFileService">
            <summary>
            Implement thread safe data file data access
            </summary>
        </member>
        <member name="P:LiteDB.Engine.DataFileService.Length">
            <summary>
            Get data file stream length
            </summary>
        </member>
        <member name="M:LiteDB.Engine.DataFileService.SetLength(System.Int64)">
            <summary>
            Set datafile with new length
            </summary>
        </member>
        <member name="M:LiteDB.Engine.DataFileService.ReadPage(System.Int64)">
            <summary>
            Read page bytes from disk (use stream pool) - Always return a fresh (never used) page instance.
            </summary>
        </member>
        <member name="M:LiteDB.Engine.DataFileService.ReadZeroPages">
            <summary>
            Read all zero pages inside datafile - zero pages was loaded by full empty of 
            </summary>
        </member>
        <member name="M:LiteDB.Engine.DataFileService.WritePages(System.Collections.Generic.IEnumerable{LiteDB.Engine.BasePage})">
            <summary>
            Write all pages to disk on absolute position (flush after write)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.DataFileService.CreateDatafile(System.IO.Stream,System.Int64)">
            <summary>
            Create new datafile based in empty Stream
            </summary>
        </member>
        <member name="M:LiteDB.Engine.DataFileService.Dispose">
            <summary>
            Dispose all stream in pool and writer
            </summary>
        </member>
        <member name="M:LiteDB.Engine.DataService.Insert(LiteDB.Engine.CollectionPage,LiteDB.Engine.ChunkStream)">
            <summary>
            Insert data inside a datapage. Returns dataPageID that indicates the first page
            </summary>
        </member>
        <member name="M:LiteDB.Engine.DataService.Update(LiteDB.Engine.CollectionPage,LiteDB.Engine.PageAddress,LiteDB.Engine.ChunkStream)">
            <summary>
            Update data inside a datapage. If new data can be used in same datapage, just update. Otherwise, copy content to a new ExtendedPage
            </summary>
        </member>
        <member name="M:LiteDB.Engine.DataService.Read(LiteDB.Engine.DataBlock)">
            <summary>
            Create Stream with chunck data (from ExtendPages) or from datablock Data
            </summary>
        </member>
        <member name="M:LiteDB.Engine.DataService.GetBlock(LiteDB.Engine.PageAddress)">
            <summary>
            Get a data block from a DataPage using address
            </summary>
        </member>
        <member name="M:LiteDB.Engine.DataService.Delete(LiteDB.Engine.CollectionPage,LiteDB.Engine.PageAddress)">
            <summary>
            Delete one dataBlock
            </summary>
        </member>
        <member name="M:LiteDB.Engine.DataService.StoreExtendData(LiteDB.Engine.ExtendPage,LiteDB.Engine.ChunkStream)">
            <summary>
            Store all bytes in one extended page. If data ir bigger than a page, store in more pages and make all in sequence
            </summary>
        </member>
        <member name="T:LiteDB.Engine.FileStreamDiskFactory">
            <summary>
            FileStream disk implementation of disk factory
            </summary>
        </member>
        <member name="P:LiteDB.Engine.FileStreamDiskFactory.Filename">
            <summary>
            Get data filename
            </summary>
        </member>
        <member name="M:LiteDB.Engine.FileStreamDiskFactory.GetDataFileStream(System.Boolean)">
            <summary>
            Create new data file FileStream instance based on filename
            </summary>
        </member>
        <member name="M:LiteDB.Engine.FileStreamDiskFactory.GetWalFileStream(System.Boolean)">
            <summary>
            Create new data file FileStream instance based on filename
            </summary>
        </member>
        <member name="M:LiteDB.Engine.FileStreamDiskFactory.GetStreamInternal(System.String,System.Boolean,System.IO.FileOptions)">
            <summary>
            Open (or create) new FileStream based on filename. Can be sequencial (for WAL writer)
            Will be only 1 single writer, so I will open write mode with no more support for writer (will do file lock)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.FileStreamDiskFactory.IsWalFileExists">
            <summary>
            Check if wal file exists
            </summary>
        </member>
        <member name="M:LiteDB.Engine.FileStreamDiskFactory.DeleteWalFile">
            <summary>
            Delete wal file
            </summary>
        </member>
        <member name="P:LiteDB.Engine.FileStreamDiskFactory.CloseOnDispose">
            <summary>
            Close all stream on end
            </summary>
        </member>
        <member name="T:LiteDB.Engine.IDiskFactory">
            <summary>
            Interface factory to provider new Stream instances for datafile/walfile resources. It's useful to multiple threads can read same datafile
            </summary>
        </member>
        <member name="P:LiteDB.Engine.IDiskFactory.Filename">
            <summary>
            Get filename
            </summary>
        </member>
        <member name="M:LiteDB.Engine.IDiskFactory.GetDataFileStream(System.Boolean)">
            <summary>
            Get new datafile stream instance
            </summary>
        </member>
        <member name="M:LiteDB.Engine.IDiskFactory.GetWalFileStream(System.Boolean)">
            <summary>
            Get new WAL file stream instance
            </summary>
        </member>
        <member name="M:LiteDB.Engine.IDiskFactory.IsWalFileExists">
            <summary>
            Return if wal file exist
            </summary>
        </member>
        <member name="M:LiteDB.Engine.IDiskFactory.DeleteWalFile">
            <summary>
            Delete physical wal file
            </summary>
        </member>
        <member name="P:LiteDB.Engine.IDiskFactory.CloseOnDispose">
            <summary>
            Indicate that factory must be dispose on finish
            </summary>
        </member>
        <member name="T:LiteDB.Engine.StreamDiskFactory">
            <summary>
            Simple stream disk implementation of disk factory - used for Memory/Temp database
            </summary>
        </member>
        <member name="P:LiteDB.Engine.StreamDiskFactory.Filename">
            <summary>
            Stream has no name (use stream type)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.StreamDiskFactory.GetDataFileStream(System.Boolean)">
            <summary>
            Use ConcurrentStream wrapper to support multi thread in same Stream (using lock control)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.StreamDiskFactory.CloseOnDispose">
            <summary>
            Do no dispose on finish
            </summary>
        </member>
        <member name="T:LiteDB.Engine.IndexService">
            <summary>
            Implement a Index service - Add/Remove index nodes on SkipList
            Based on: http://igoro.com/archive/skip-lists-are-fascinating/
            </summary>
        </member>
        <member name="M:LiteDB.Engine.IndexService.CreateIndex(LiteDB.Engine.CollectionPage)">
            <summary>
            Create a new index and returns head page address (skip list)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.IndexService.AddNode(LiteDB.Engine.CollectionIndex,LiteDB.BsonValue,LiteDB.Engine.IndexNode)">
            <summary>
            Insert a new node index inside an collection index. Flip coin to know level
            </summary>
        </member>
        <member name="M:LiteDB.Engine.IndexService.AddNode(LiteDB.Engine.CollectionIndex,LiteDB.BsonValue,System.Byte,LiteDB.Engine.IndexNode)">
            <summary>
            Insert a new node index inside an collection index.
            </summary>
        </member>
        <member name="M:LiteDB.Engine.IndexService.GetNodeList(LiteDB.Engine.IndexNode,System.Boolean)">
            <summary>
            Gets all node list from any index node (go forward and backward)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.IndexService.Delete(LiteDB.Engine.CollectionIndex,LiteDB.Engine.PageAddress)">
            <summary>
            Deletes an indexNode from a Index and adjust Next/Prev nodes
            </summary>
        </member>
        <member name="M:LiteDB.Engine.IndexService.DropIndex(LiteDB.Engine.CollectionIndex)">
            <summary>
            Drop all indexes pages. Each index use a single page sequence
            </summary>
        </member>
        <member name="M:LiteDB.Engine.IndexService.GetNode(LiteDB.Engine.PageAddress)">
            <summary>
            Get a node inside a page using PageAddress - Returns null if address IsEmpty
            </summary>
        </member>
        <member name="M:LiteDB.Engine.IndexService.FlipCoin">
            <summary>
            Flip coin - skip list - returns level node (start in 1)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.IndexService.FindAll(LiteDB.Engine.CollectionIndex,System.Int32)">
            <summary>
            Return all index nodes from an index
            </summary>
        </member>
        <member name="M:LiteDB.Engine.IndexService.Find(LiteDB.Engine.CollectionIndex,LiteDB.BsonValue,System.Boolean,System.Int32)">
            <summary>
            Find first node that index match with value. If not found but sibling = true, returns near node (only non-unique index)
            Before find, value must be normalized
            </summary>
        </member>
        <member name="M:LiteDB.Engine.IndexService.FindBoundary(LiteDB.Engine.CollectionIndex,LiteDB.Engine.IndexNode,LiteDB.BsonValue,System.Int32,System.Int32)">
            <summary>
            Goto the first/last occurrence of this index value
            </summary>
        </member>
        <member name="T:LiteDB.Engine.LockService">
            <summary>
            Lock service are collection-based locks. Lock will support any threads reading at same time. Writing operations will be locked
            based on collection. Eventualy, write operation can change header page that has an exclusive locker for.
            </summary>
        </member>
        <member name="P:LiteDB.Engine.LockService.Timeout">
            <summary>
            Get lock timeout
            </summary>
        </member>
        <member name="P:LiteDB.Engine.LockService.IsInTransaction">
            <summary>
            Return if current thread have open transaction
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LockService.EnterTransaction">
            <summary>
            Use ReaderWriterLockSlim to manage only one transaction per thread
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LockService.ExitTransaction">
            <summary>
            Exit transaction locker
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LockService.EnterRead(System.String)">
            <summary>
            Enter collection in read lock mode
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LockService.ExitRead(System.String)">
            <summary>
            Exit read lock
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LockService.EnterReserved(System.String)">
            <summary>
            Enter collection in reserved lock mode
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LockService.ExitReserved(System.String)">
            <summary>
            Exit reserved lock
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LockService.EnterReserved(System.Boolean)">
            <summary>
            Enter all database in reserved lock. Wait for all reader/writers. 
            If exclusive = false, new readers can read but no writers can write. If exclusive = true, no new readers/writers
            </summary>
        </member>
        <member name="M:LiteDB.Engine.LockService.ExitReserved(System.Boolean)">
            <summary>
            Exit reserved lock
            </summary>
        </member>
        <member name="T:LiteDB.Engine.LogEntry">
            <summary>
            Represent a single log entry
            </summary>
        </member>
        <member name="T:LiteDB.Engine.Logger">
            <summary>
            Logger class to store important information about database running. Log errors and some important
            information only. Can
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Logger.#ctor(System.Byte,System.Action{LiteDB.Engine.LogEntry})">
            <summary>
            Initialize logger class using a custom logging level (see Logger.NONE to Logger.FULL)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.Logger.Level">
            <summary>
            To full logger use Logger.FULL or any combination of Logger constants like Level = Logger.ERROR | Logger.COMMAND | Logger.DISK
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Logger.Error(System.Exception)">
            <summary>
            Log any database error excption before send error to user
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Logger.Info(System.String)">
            <summary>
            Log database information about important facts
            </summary>
        </member>
        <member name="T:LiteDB.Engine.Snapshot">
            <summary>
            Represent a single snapshot
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Snapshot.WriteMode(System.Boolean)">
            <summary>
            Enter snapshot in write lock (if not already in write mode)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Snapshot.GetDirtyPages(System.Boolean)">
            <summary>
            Return all dirty pages
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Snapshot.ClearLocalPages">
            <summary>
            Clear all localpages 
            </summary>
        </member>
        <member name="P:LiteDB.Engine.Snapshot.LocalPagesCount">
            <summary>
            Get local pages counter
            </summary>
        </member>
        <member name="P:LiteDB.Engine.Snapshot.CollectionPage">
            <summary>
            Get/Set collection reference. Returns null if not exists in collections
            </summary>
        </member>
        <member name="P:LiteDB.Engine.Snapshot.CollectionName">
            <summary>
            Get collection name - always have a value
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Snapshot.GetCollectionService">
            <summary>
            Create instance of collection service using snapshot variables
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Snapshot.Dispose">
            <summary>
            Unlock all collections locks on dispose
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Snapshot.Initialize">
            <summary>
            Initializer snapshot instance, cleaning any loadad page and getting new ReadVersion
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Snapshot.GetPage``1(System.UInt32)">
            <summary>
            Get a page for this transaction: try local, wal-index or datafile. Must keep cloned instance of this page in this transaction
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Snapshot.SetDirty(LiteDB.Engine.BasePage)">
            <summary>
            Set page was dirty
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Snapshot.GetSeqPages``1(System.UInt32)">
            <summary>
            Read all sequences pages from a start pageID (using NextPageID)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Snapshot.NewPage``1(LiteDB.Engine.BasePage)">
            <summary>
            Get a new empty page - can be a reused page (EmptyPage) or a clean one (extend datafile)
            FreeEmptyPageID use a single linked list to avoid read old pages. Insert/Delete pages from this list is always from begin
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Snapshot.DeletePages(System.UInt32)">
            <summary>
            Delete all sequence of pages based on first pageID
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Snapshot.DeletePage(System.UInt32)">
            <summary>
            Delete a page using pageID - transform them in Empty Page and add to EmptyPageList
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Snapshot.GetFreePage``1(System.UInt32,System.Int32)">
            <summary>
            Returns a page that contains space enough to data to insert new object - if one does not exit, creates a new page.
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Snapshot.AddOrRemoveToFreeList(System.Boolean,LiteDB.Engine.BasePage,LiteDB.Engine.BasePage,System.UInt32@)">
            <summary>
            Add or Remove a page in a sequence
            </summary>
            <param name="add">Indicate that will add or remove from FreeList</param>
            <param name="page">Page to add or remove from FreeList</param>
            <param name="startPage">Page reference where start the header list node</param>
            <param name="fieldPageID">Field reference, from startPage</param>
        </member>
        <member name="M:LiteDB.Engine.Snapshot.AddToFreeList(LiteDB.Engine.BasePage,LiteDB.Engine.BasePage,System.UInt32@)">
            <summary>
            Add a page in free list in desc free size order
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Snapshot.RemoveToFreeList(LiteDB.Engine.BasePage,LiteDB.Engine.BasePage,System.UInt32@)">
            <summary>
            Remove a page from list - the ease part
            </summary>
        </member>
        <member name="M:LiteDB.Engine.Snapshot.MoveToFreeList(LiteDB.Engine.BasePage,LiteDB.Engine.BasePage,System.UInt32@)">
            <summary>
            When a page is already on a list it's more efficient just move comparing with siblings
            </summary>
        </member>
        <member name="T:LiteDB.Engine.TransactionService">
            <summary>
            Represent a single transaction service. Need a new instance for each transaction.
            You must run each transaction in a different thread - no 2 transaction in same thread (locks as per-thread)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.TransactionService.CreateSnapshot(LiteDB.Engine.LockMode,System.String,System.Boolean)">
            <summary>
            Create (or get from cache) snapshot and return. Snapshot are thread-safe. Do not call Dispose of snapshot because transaction will do this on end
            </summary>
        </member>
        <member name="M:LiteDB.Engine.TransactionService.Safepoint">
            <summary>
            If current transaction contains too much pages, now is safe to remove clean pages from memory and flush to wal disk dirty pages
            </summary>
        </member>
        <member name="M:LiteDB.Engine.TransactionService.PersistDirtyPages(System.Boolean,System.Boolean)">
            <summary>
            Persist all dirty in-memory pages (in all snapshots) and clear local pages (even clean pages)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.TransactionService.Commit">
            <summary>
            Write pages into disk and confirm transaction in wal-index. Returns true if any dirty page was updated
            </summary>
        </member>
        <member name="M:LiteDB.Engine.TransactionService.Rollback(System.Boolean)">
            <summary>
            Rollback transaction operation - ignore all modified pages and return new pages into disk
            </summary>
        </member>
        <member name="M:LiteDB.Engine.TransactionService.ReturnNewPages">
            <summary>
            Return added pages when occurs an rollback transaction (run this only in rollback). Create new transactionID and add into
            WAL file all new pages as EmptyPage in a linked order - also, update SharedPage before store
            </summary>
        </member>
        <member name="M:LiteDB.Engine.TransactionService.Shutdown">
            <summary>
            Define this transaction must stop working and release resources because main thread are shutting down.
            If was called by same thread, call rollback now (with no ReturnNewPages)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.TransactionService.Done(LiteDB.Engine.TransactionState)">
            <summary>
            Finish transaction, release lock and call done action
            </summary>
        </member>
        <member name="T:LiteDB.Engine.WalFileService">
            <summary>
            </summary>
        </member>
        <member name="P:LiteDB.Engine.WalFileService.LimitSize">
            <summary>
            Get limit of datafile in bytes (not WAL file size)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.WalFileService.Length">
            <summary>
            Get virtual file length
            </summary>
        </member>
        <member name="M:LiteDB.Engine.WalFileService.ReadPage(System.Int64)">
            <summary>
            Read page bytes from disk (use stream pool) - Always return a fresh (never used) page instance.
            </summary>
        </member>
        <member name="M:LiteDB.Engine.WalFileService.HasPages">
            <summary>
            Return if WAL file contains pages
            </summary>
        </member>
        <member name="M:LiteDB.Engine.WalFileService.ReadPages(System.Boolean)">
            <summary>
            Read all pages inside wal file in order. Locking writer to avoid writing durting my disk read. Read direct from disk with no cache
            </summary>
        </member>
        <member name="M:LiteDB.Engine.WalFileService.WritePages(System.Collections.Generic.IEnumerable{LiteDB.Engine.BasePage},System.Collections.Generic.IDictionary{System.UInt32,LiteDB.Engine.PagePosition})">
            <summary>
            Add all pages to queue using virtual position. Pages in this queue will be write on disk in async task
            </summary>
        </member>
        <member name="M:LiteDB.Engine.WalFileService.Flush">
            <summary>
            Do a full flush do disk
            </summary>
        </member>
        <member name="M:LiteDB.Engine.WalFileService.Clear">
            <summary>
            Clear WAL file content and reset writer position
            </summary>
        </member>
        <member name="M:LiteDB.Engine.WalFileService.Delete">
            <summary>
            Delete WAL file (check before if is empty) and re-initialize writer for new file
            </summary>
        </member>
        <member name="M:LiteDB.Engine.WalFileService.Dispose">
            <summary>
            Dispose all stream in pool and async writer
            </summary>
        </member>
        <member name="P:LiteDB.Engine.WalService.CurrentReadVersion">
            <summary>
            Get current read version for all new transactions
            </summary>
        </member>
        <member name="M:LiteDB.Engine.WalService.GetPageIndex(System.UInt32,System.Int32)">
            <summary>
            Checks if a Page/Version are in WAL-index memory. Consider version that are below parameter. Returns PagePosition of this page inside WAL-file or Empty if page doesn't found.
            </summary>
        </member>
        <member name="M:LiteDB.Engine.WalService.ConfirmTransaction(System.Guid,System.Collections.Generic.ICollection{LiteDB.Engine.PagePosition})">
            <summary>
            Write last confirmation page into all and update all indexes
            </summary>
        </member>
        <member name="M:LiteDB.Engine.WalService.Checkpoint(System.Boolean,LiteDB.Engine.HeaderPage,System.Boolean)">
            <summary>
            Do WAL checkpoint coping confirmed pages from WAL file to datafile. 
            Return how many pages was copied from WAL file to data file
            </summary>
        </member>
        <member name="M:LiteDB.Engine.WalService.LoadConfirmedTransactions">
            <summary>
            Load all confirmed transactions from WAL file (used only when open datafile)
            </summary>
        </member>
        <member name="T:LiteDB.Engine.SqlParser">
            <summary>
            Internal class to parse and execute sql-like commands
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SqlParser.ParseAnalyze">
            <summary>
            ANALYZE [{collection0}, {collection1}, ...]
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SqlParser.ParseBegin">
            <summary>
            BEGIN [ TRANS | TRANSACTION ]
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SqlParser.ParseCheckpoint">
            <summary>
            CHECKPOINT [DELETE]
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SqlParser.ParseCommit">
            <summary>
            COMMIT [ TRANS | TRANSACTION ]
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SqlParser.ParseCreate">
            <summary>
            CREATE [ UNQIUE ] INDEX {indexName} ON {collection} ({indexExpr})
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SqlParser.ParseDelete">
            <summary>
            DELETE {collection} WHERE {whereExpr}
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SqlParser.ParseDrop">
            <summary>
            DROP INDEX {collection}.{indexName}
            DROP COLLECTION {collection}
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SqlParser.ParseInsert">
            <summary>
            INSERT INTO {collection} VALUES {doc0} [, {docN}] [ WITH ID={type} ] ]
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SqlParser.ParseWithAutoId">
            <summary>
            Parse :[type] for AutoId (just after collection name)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SqlParser.ParseListOfExpressions">
            <summary>
            {expr0}, {expr1}, ..., {exprN}
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SqlParser.ParseListOfDocuments">
            <summary>
            {doc0}, {doc1}, ..., {docN} {EOF|;}
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SqlParser.ParseListOfWords">
            <summary>
            {word0}, {word1}, ..., {wordN}
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SqlParser.ParseRename">
            <summary>
            RENAME COLLECTION {collection} TO {newName}
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SqlParser.ParseRollback">
            <summary>
            ROLLBACK [ TRANS | TRANSACTION ]
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SqlParser.ParseSelect(System.Boolean)">
            <summary>
               SELECT [ ALL ] {selectExpr}
               [ INTO {newcollection|FILE} [ : {autoId} ] ]
               [ FROM {collection|FILE} ]
            [ INCLUDE {pathExpr0} [, {pathExprN} ]
              [ WHERE {filterExpr} ]
              [ GROUP BY {groupByExpr} ]
             [ HAVING {filterExpr} ]
              [ ORDER BY {orderByExpr} [ ASC | DESC ] ]
              [ LIMIT {number} ]
             [ OFFSET {number} ]
                [ FOR UPDATE ]
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SqlParser.ParseCollection(LiteDB.Tokenizer)">
            <summary>
            Read collection name and parameter (in case of system collections)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SqlParser.ParseCollection(LiteDB.Tokenizer,System.String@,LiteDB.BsonValue@)">
            <summary>
            Read collection name and parameter (in case of system collections)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SqlParser.ParseSet">
            <summary>
            SET {key} = {value}
            SET {@parameter} = {command}
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SqlParser.ParseSetParameter">
            <summary>
            Read new command and set return of this value into output parameter
            </summary>
            <returns></returns>
        </member>
        <member name="M:LiteDB.Engine.SqlParser.ParseSetValue(LiteDB.Token)">
            <summary>
            Read key=value to update database settings
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SqlParser.ParseShrink">
            <summary>
            SHRINK
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SqlParser.ParseUpadate">
            <summary>
            UPDATE - will merge current document with modify expression
             UPDATE {collection}
                SET {extendExpr}
            [ WHERE {whereExpr} ]
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SqlParser.ParseVaccum">
            <summary>
            VACCUM
            </summary>
        </member>
        <member name="T:LiteDB.Engine.SqlKeywords">
            <summary>
            Internal class to parse and execute sql-like commands
            </summary>
        </member>
        <member name="F:LiteDB.Engine.SqlKeywords.Methods">
            <summary>
            Get all methods names
            </summary>
        </member>
        <member name="T:LiteDB.Engine.ChunkStream">
            <summary>
            Implement stream reader for chunk data (IEnumerable of byte array as data source)
            Support only Read and Seek (fordward direction)
            </summary>
        </member>
        <member name="T:LiteDB.Engine.ConcurrentStream">
            <summary>
            Implement internal thread-safe Stream using lock control
            </summary>
        </member>
        <member name="T:LiteDB.Engine.TempStream">
            <summary>
            Implement a temporary stream that uses MemoryStream until get LIMIT bytes, then copy all to tempoary disk file and delete on dispose
            Can be pass 
            </summary>
        </member>
        <member name="P:LiteDB.Engine.TempStream.InMemory">
            <summary>
            Indicate that stream are all in memory
            </summary>
        </member>
        <member name="P:LiteDB.Engine.TempStream.InDisk">
            <summary>
            Indicate that stream is now on this
            </summary>
        </member>
        <member name="P:LiteDB.Engine.TempStream.Filename">
            <summary>
            Get temp disk filename (if null will be generate only when create file)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CollectionIndex.Slot">
            <summary>
            Represent slot position on index array on dataBlock/collection indexes - non-persistable
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CollectionIndex.Name">
            <summary>
            Index name
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CollectionIndex.Expression">
            <summary>
            Get index expression (path or expr)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CollectionIndex.Unique">
            <summary>
            Indicate if this index has distinct values only
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CollectionIndex.HeadNode">
            <summary>
            Head page address for this index
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CollectionIndex.TailNode">
            <summary>
            A link pointer to tail node
            </summary>
        </member>
        <member name="F:LiteDB.Engine.CollectionIndex.FreeIndexPageID">
            <summary>
            Get a reference for the free list index page - its private list per collection/index (must be a Field to be used as reference parameter)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CollectionIndex.MaxLevel">
            <summary>
            Persist max level used
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CollectionIndex.KeyCount">
            <summary>
            Counter of keys in this index
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CollectionIndex.UniqueKeyCount">
            <summary>
            Counter of unique keys in this index (online but be dirty on delete index nodes... will fix on next analyze)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CollectionIndex.Density">
            <summary>
            Get index density based on KeyCount vs UniqueKeyCount. Value are from 0 to 1.
            0 means completed unique keys (best)
            1 means has only 1 single unique key in all index (worst)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CollectionIndex.IsEmpty">
            <summary>
            Returns if this index slot is empty and can be used as new index
            </summary>
        </member>
        <member name="P:LiteDB.Engine.CollectionIndex.Page">
            <summary>
            Get a reference for page
            </summary>
        </member>
        <member name="M:LiteDB.Engine.CollectionIndex.Clear">
            <summary>
            Clear all index information
            </summary>
        </member>
        <member name="P:LiteDB.Engine.DataBlock.Position">
            <summary>
            Position of this dataBlock inside a page (store only Position.Index)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.DataBlock.ExtendPageID">
            <summary>
            If object is bigger than this page - use a ExtendPage (and do not use Data array)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.DataBlock.DocumentLength">
            <summary>
            Get document length (from Data array or from ExtendPages)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.DataBlock.Data">
            <summary>
            Data of a record - could be empty if is used in ExtedPage
            </summary>
        </member>
        <member name="P:LiteDB.Engine.DataBlock.Page">
            <summary>
            Get a reference for page
            </summary>
        </member>
        <member name="P:LiteDB.Engine.DataBlock.BlockLength">
            <summary>
            Get length of this dataBlock (persist as ushort 2 bytes)
            </summary>
        </member>
        <member name="T:LiteDB.Engine.IndexNode">
            <summary>
            Represent a index node inside a Index Page
            </summary>
        </member>
        <member name="P:LiteDB.Engine.IndexNode.Position">
            <summary>
            Position of this node inside a IndexPage - Store only Position.Index
            </summary>
        </member>
        <member name="P:LiteDB.Engine.IndexNode.Slot">
            <summary>
            Slot position of index in data block
            </summary>
        </member>
        <member name="P:LiteDB.Engine.IndexNode.PrevNode">
            <summary>
            Prev node in same document list index nodes
            </summary>
        </member>
        <member name="P:LiteDB.Engine.IndexNode.NextNode">
            <summary>
            Next node in same document list index nodes
            </summary>
        </member>
        <member name="P:LiteDB.Engine.IndexNode.Prev">
            <summary>
            Link to prev value (used in skip lists - Prev.Length = Next.Length)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.IndexNode.Next">
            <summary>
            Link to next value (used in skip lists - Prev.Length = Next.Length)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.IndexNode.KeyLength">
            <summary>	
            Length of key - used for calculate Node size	
            </summary>	
        </member>
        <member name="P:LiteDB.Engine.IndexNode.Key">
            <summary>
            The object value that was indexed
            </summary>
        </member>
        <member name="P:LiteDB.Engine.IndexNode.DataBlock">
            <summary>
            Reference for a datablock - the value
            </summary>
        </member>
        <member name="P:LiteDB.Engine.IndexNode.Page">
            <summary>
            Get page reference
            </summary>
        </member>
        <member name="M:LiteDB.Engine.IndexNode.NextPrev(System.Int32,System.Int32)">
            <summary>
            Returns Next (order == 1) OR Prev (order == -1)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.IndexNode.IsHeadTail(LiteDB.Engine.CollectionIndex)">
            <summary>
            Returns if this node is header or tail from collection Index
            </summary>
        </member>
        <member name="P:LiteDB.Engine.IndexNode.Length">
            <summary>
            Get the length size of this node in disk - not persistable
            </summary>
        </member>
        <member name="P:LiteDB.Engine.IndexNode.CacheDocument">
            <summary>
            Cached document - if null, use DataBlock
            </summary>
        </member>
        <member name="T:LiteDB.Engine.LockMode">
            <summary>
            Represents a snapshot lock mode
            </summary>
        </member>
        <member name="F:LiteDB.Engine.LockMode.Read">
            <summary>
            Read only snap with read lock
            </summary>
        </member>
        <member name="F:LiteDB.Engine.LockMode.Write">
            <summary>
            Read/Write snapshot with reserved lock
            </summary>
        </member>
        <member name="F:LiteDB.Engine.LockMode.None">
            <summary>
            Current snap has no read/write lock
            </summary>
        </member>
        <member name="T:LiteDB.Engine.PageAddress">
            <summary>
            Represents a page address inside a page structure - index could be byte offset position OR index in a list (6 bytes)
            </summary>
        </member>
        <member name="F:LiteDB.Engine.PageAddress.PageID">
            <summary>
            PageID (4 bytes)
            </summary>
        </member>
        <member name="F:LiteDB.Engine.PageAddress.Index">
            <summary>
            Index inside page (2 bytes)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.PageAddress.IsEmpty">
            <summary>
            Returns true if this PageAdress is empty value
            </summary>
        </member>
        <member name="T:LiteDB.Engine.PagePosition">
            <summary>
            Represents a page position after save in disk. Used in WAL files where PageID do not match with PagePosition
            </summary>
        </member>
        <member name="F:LiteDB.Engine.PagePosition.PageID">
            <summary>
            PageID (4 bytes)
            </summary>
        </member>
        <member name="F:LiteDB.Engine.PagePosition.Position">
            <summary>
            Position in disk
            </summary>
        </member>
        <member name="P:LiteDB.Engine.PagePosition.IsEmpty">
            <summary>
            Checks if current PagePosition is empty value
            </summary>
        </member>
        <member name="T:LiteDB.Engine.TransactionPages">
            <summary>
            Represent a simple structure to store added/removed pages in a transaction. One instance per transaction
            </summary>
        </member>
        <member name="P:LiteDB.Engine.TransactionPages.TransactionSize">
            <summary>
            Get how many pages are involved in this transaction across all snapshots
            </summary>
        </member>
        <member name="P:LiteDB.Engine.TransactionPages.DirtyPagesWal">
            <summary>
            Contains all dirty pages already persist in WAL (used in all snapshots). Store in [uint, PagePosition] to reuse same method in save pages into wal and get saved page positions on wal
            </summary>
        </member>
        <member name="P:LiteDB.Engine.TransactionPages.NewPages">
            <summary>
            Handle created pages during transaction (for rollback) - Is a list because order is important
            </summary>
        </member>
        <member name="P:LiteDB.Engine.TransactionPages.FirstDeletedPageID">
            <summary>
            First deleted pageID 
            </summary>
        </member>
        <member name="P:LiteDB.Engine.TransactionPages.LastDeletedPageID">
            <summary>
            Last deleted pageID
            </summary>
        </member>
        <member name="P:LiteDB.Engine.TransactionPages.DeletedPages">
            <summary>
            Get deleted page count
            </summary>
        </member>
        <member name="P:LiteDB.Engine.TransactionPages.NewCollections">
            <summary>
            New collections added in this transaction
            </summary>
        </member>
        <member name="P:LiteDB.Engine.TransactionPages.DeletedCollection">
            <summary>
            Deleted collection in this transaction (support only 1 drop collection per transaction)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.TransactionPages.HeaderChanged">
            <summary>
            Detect if this transaction will need persist header page (has added/deleted pages or added/deleted collections)
            </summary>
        </member>
        <member name="T:LiteDB.Engine.TransactionState">
            <summary>
            Represents a transaction state
            </summary>
        </member>
        <member name="F:LiteDB.Engine.TransactionState.New">
            <summary>
            Transaction was not used yet, have no snap and no locks
            </summary>
        </member>
        <member name="F:LiteDB.Engine.TransactionState.Active">
            <summary>
            Transaction are in use with one or more snaps in memory with page in use
            </summary>
        </member>
        <member name="F:LiteDB.Engine.TransactionState.Commited">
            <summary>
            Transaction was fully commited into wal disk and confirmed and all snaps are unlocked
            </summary>
        </member>
        <member name="F:LiteDB.Engine.TransactionState.Aborted">
            <summary>
            Transaction was completed aborted and all pages are clear. If any page are persisted in wal file has no confirmation and will not valid in next checkpoint
            Used NewPages are reverted in header page
            All snaps are clear and unlocked
            </summary>
        </member>
        <member name="T:LiteDB.Engine.SysQuery">
            <summary>
            This class implement $query experimental system function to run sub-queries. It's experimental only - possible not be present in final release
            </summary>
        </member>
        <member name="T:LiteDB.Engine.SystemCollection">
            <summary>
            Implement a simple system collection with input data only (to use Output must inherit this class)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.SystemCollection.Name">
            <summary>
            Get system collection name (must starts with $)
            </summary>
        </member>
        <member name="P:LiteDB.Engine.SystemCollection.IsFunction">
            <summary>
            Indicate this system collection as a function collection (has parameters to be called)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SystemCollection.Input(LiteDB.Engine.LiteEngine,LiteDB.BsonValue)">
            <summary>
            Get input data source factory
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SystemCollection.Output(System.Collections.Generic.IEnumerable{LiteDB.BsonValue},LiteDB.BsonValue)">
            <summary>
            Get output data source factory (must implement in inherit class)
            </summary>
        </member>
        <member name="M:LiteDB.Engine.SystemCollection.GetOption``1(LiteDB.BsonValue,System.Boolean,System.String,``0)">
            <summary>
            Static helper to read options arg as plain value or as document fields
            </summary>
        </member>
        <member name="T:LiteDB.Constants">
            <summary>
            Class with all constants used in LiteDB + Debbuger HELPER
            </summary>
        </member>
        <member name="F:LiteDB.Constants.PAGE_SIZE">
            <summary>
            The size of each page in disk - new v5 use 8192 as all major databases
            </summary>
        </member>
        <member name="F:LiteDB.Constants.PAGE_HEADER_SIZE">
            <summary>
            This size is used bytes in header pages 33 bytes (+31 reserved to future use) = 64 bytes
            </summary>
        </member>
        <member name="F:LiteDB.Constants.PAGE_AVAILABLE_BYTES">
            <summary>
            Bytes available to store data removing page header size - 8128 bytes
            </summary>
        </member>
        <member name="F:LiteDB.Constants.DATA_RESERVED_BYTES">
            <summary>
            If a Data Page has less that free space, it's considered full page for new items. Can be used only for update (DataPage)
            </summary>
        </member>
        <member name="F:LiteDB.Constants.INDEX_RESERVED_BYTES">
            <summary>
            If a Index Page has less that this free space, it's considered full page for new items.
            </summary>
        </member>
        <member name="F:LiteDB.Constants.COLLECTION_NAME_MAX_LENGTH">
            <summary>
            Define max length to be used in a single collection name
            </summary>
        </member>
        <member name="F:LiteDB.Constants.HEADER_PAGE_FIXED_DATA_SIZE">
            <summary>
            Define (and reserve) bytes do be fixed in header page (are not considering collection name/id list)
            </summary>
        </member>
        <member name="F:LiteDB.Constants.MAX_COLLECTIONS_NAME_SIZE">
            <summary>
            Represent maximum bytes that all collections names can be used in collection list page (must fit inside a single header page)
            Do not change - it's calculated 
            </summary>
        </member>
        <member name="F:LiteDB.Constants.INDEX_NAME_MAX_LENGTH">
            <summary>
            Define index name max length
            </summary>
        </member>
        <member name="F:LiteDB.Constants.INDEX_PER_COLLECTION">
            <summary>
            Total indexes per collection - it's fixed because I will used fixed arrays allocations
            </summary>
        </member>
        <member name="F:LiteDB.Constants.MAX_LEVEL_LENGTH">
            <summary>
            Max level used on skip list (index).
            </summary>
        </member>
        <member name="F:LiteDB.Constants.MAX_INDEX_KEY_LENGTH">
            <summary>
            Max size of a index entry - usde for string, binary, array and documents
            </summary>
        </member>
        <member name="F:LiteDB.Constants.MAX_CACHE_SIZE">
            <summary>
            DocumentLoader max cache size
            </summary>
        </member>
        <member name="F:LiteDB.Constants.MAX_CURSOR_HISTORY">
            <summary>
            Max cursor info history
            </summary>
        </member>
        <member name="F:LiteDB.Constants.V7_TRANSID">
            <summary>
            This variable are used to identify that current datafile are v7 version and must be upgrade
            v7 has small page header so is not possible check using FILE_VERSION position
            </summary>
        </member>
        <member name="M:LiteDB.Constants.DEBUG(System.Boolean,System.String)">
            <summary>
            Stop VisualStudio if condition are true and we are running over #DEBUG - great for testing unexpected flow
            </summary>
        </member>
        <member name="M:LiteDB.BinaryExtensions.IsFullZero(System.Byte[])">
            <summary>
            Very fast way to check if all byte array is full of zero
            </summary>
        </member>
        <member name="M:LiteDB.BinaryReaderExtensions.ReadBsonValue(System.IO.BinaryReader,System.UInt16,System.Boolean)">
            <summary>
            Read BSON value from reader
            </summary>
        </member>
        <member name="M:LiteDB.BinaryWriterExtensions.WriteFixedString(System.IO.BinaryWriter,System.String)">
            <summary>
            Write string into writer without length information (must know when read)
            </summary>
        </member>
        <member name="M:LiteDB.DateExtensions.Truncate(System.DateTime)">
            <summary>
            Truncate DateTime in milliseconds
            </summary>
        </member>
        <member name="M:LiteDB.DictionaryExtensions.NextIndex``1(System.Collections.Generic.Dictionary{System.UInt16,``0})">
            <summary>
            Get free index based on dictionary count number (if is in use, move to next number)
            </summary>
        </member>
        <member name="M:LiteDB.DictionaryExtensions.GetValue``1(System.Collections.Generic.Dictionary{System.String,System.String},System.String,``0)">
            <summary>
            Get value from dictionary converting datatype T
            </summary>
        </member>
        <member name="M:LiteDB.DictionaryExtensions.GetFileSize(System.Collections.Generic.Dictionary{System.String,System.String},System.String,System.Int64)">
            <summary>
            Get a value from a key converted in file size format: "1gb", "10 mb", "80000"
            </summary>
        </member>
        <member name="M:LiteDB.ExpressionExtensions.GetPath(System.Linq.Expressions.Expression)">
            <summary>
            Get Path (better ToString) from an Expression.
            Support multi levels: x => x.Customer.Address
            Support list levels: x => x.Addresses.Select(z => z.StreetName)
            </summary>
        </member>
        <member name="M:LiteDB.IOExceptionExtensions.IsLocked(System.IO.IOException)">
            <summary>
            Detect if exception is an Locked exception
            </summary>
        </member>
        <member name="M:LiteDB.IOExceptionExtensions.WaitFor(System.Int32)">
            <summary>
            WaitFor function used in all platforms
            </summary>
        </member>
        <member name="M:LiteDB.StreamExtensions.FlushToDisk(System.IO.Stream)">
            <summary>
            If Stream are FileStream, flush content direct to disk (avoid OS cache)
            </summary>
        </member>
        <member name="M:LiteDB.StreamExtensions.TryLock(System.IO.Stream,System.TimeSpan)">
            <summary>
            Lock FileStream in fixed page 2. Support try/catch for some type
            </summary>
        </member>
        <member name="M:LiteDB.StringExtensions.IsWord(System.String)">
            <summary>
            Test if string is simple word pattern ([a-Z$_])
            </summary>
        </member>
        <member name="M:LiteDB.StringExtensions.SqlLike(System.String,System.String)">
            <summary>
            Implement SqlLike in C# string 
            https://stackoverflow.com/a/8583383/3286260
            </summary>
        </member>
        <member name="M:LiteDB.StringExtensions.SqlLikeStartsWith(System.String,System.Boolean@)">
            <summary>
            Get first string before any %, _, [... used to index startswith - out if has more string pattern after found wildcard
            </summary>
        </member>
        <member name="T:LiteDB.FileHelper">
            <summary>
            A simple file helper tool with static methods
            </summary>
        </member>
        <member name="M:LiteDB.FileHelper.GetTempFile(System.String,System.String,System.Boolean)">
            <summary>
            Create a temp filename based on original filename - checks if file exists (if exists, append counter number)
            </summary>
        </member>
        <member name="M:LiteDB.FileHelper.TryExec(System.Action,System.TimeSpan)">
            <summary>
            Try execute some action while has lock exception
            </summary>
        </member>
        <member name="M:LiteDB.FileHelper.TryDelete(System.String)">
            <summary>
            Try delete a file that can be in use by another
            </summary>
        </member>
        <member name="T:LiteDB.LiteException">
            <summary>
            The main exception for LiteDB
            </summary>
        </member>
        <member name="T:LiteDB.MimeTypeConverter">
            <summary>
            Convert filename to mimetype (http://stackoverflow.com/questions/1029740/get-mime-type-from-filename-extension)
            </summary>
        </member>
        <member name="T:LiteDB.StorageUnitHelper">
            <summary>
            Parse/Format storage unit format (kb/mb/gb)
            </summary>
        </member>
        <member name="M:LiteDB.StorageUnitHelper.ParseFileSize(System.String)">
            <summary>
            Convert storage unit string "1gb", "10 mb", "80000" to long bytes
            </summary>
        </member>
        <member name="M:LiteDB.StorageUnitHelper.FormatFileSize(System.Int64)">
            <summary>
            Format a long file length to pretty file unit
            </summary>
        </member>
        <member name="T:LiteDB.TokenType">
            <summary>
            ASCII char names: https://www.ascii.cl/htmlcodes.htm
            </summary>
        </member>
        <member name="F:LiteDB.TokenType.OpenBrace">
            <summary> { </summary>
        </member>
        <member name="F:LiteDB.TokenType.CloseBrace">
            <summary> } </summary>
        </member>
        <member name="F:LiteDB.TokenType.OpenBracket">
            <summary> [ </summary>
        </member>
        <member name="F:LiteDB.TokenType.CloseBracket">
            <summary> ] </summary>
        </member>
        <member name="F:LiteDB.TokenType.OpenParenthesis">
            <summary> ( </summary>
        </member>
        <member name="F:LiteDB.TokenType.CloseParenthesis">
            <summary> ) </summary>
        </member>
        <member name="F:LiteDB.TokenType.Comma">
            <summary> , </summary>
        </member>
        <member name="F:LiteDB.TokenType.Colon">
            <summary> : </summary>
        </member>
        <member name="F:LiteDB.TokenType.SemiColon">
            <summary> ; </summary>
        </member>
        <member name="F:LiteDB.TokenType.At">
            <summary> @ </summary>
        </member>
        <member name="F:LiteDB.TokenType.Hashtag">
            <summary> # </summary>
        </member>
        <member name="F:LiteDB.TokenType.Til">
            <summary> ~ </summary>
        </member>
        <member name="F:LiteDB.TokenType.Period">
            <summary> . </summary>
        </member>
        <member name="F:LiteDB.TokenType.Dollar">
            <summary> $ </summary>
        </member>
        <member name="F:LiteDB.TokenType.Exclamation">
            <summary> ! </summary>
        </member>
        <member name="F:LiteDB.TokenType.NotEquals">
            <summary> != </summary>
        </member>
        <member name="F:LiteDB.TokenType.Equals">
            <summary> = </summary>
        </member>
        <member name="F:LiteDB.TokenType.Greater">
            <summary> &gt; </summary>
        </member>
        <member name="F:LiteDB.TokenType.GreaterOrEquals">
            <summary> &gt;= </summary>
        </member>
        <member name="F:LiteDB.TokenType.Less">
            <summary> &lt; </summary>
        </member>
        <member name="F:LiteDB.TokenType.LessOrEquals">
            <summary> &lt;= </summary>
        </member>
        <member name="F:LiteDB.TokenType.Minus">
            <summary> - </summary>
        </member>
        <member name="F:LiteDB.TokenType.Plus">
            <summary> + </summary>
        </member>
        <member name="F:LiteDB.TokenType.Asterisk">
            <summary> * </summary>
        </member>
        <member name="F:LiteDB.TokenType.Slash">
            <summary> / </summary>
        </member>
        <member name="F:LiteDB.TokenType.Backslash">
            <summary> \ </summary>
        </member>
        <member name="F:LiteDB.TokenType.Percent">
            <summary> % </summary>
        </member>
        <member name="F:LiteDB.TokenType.String">
            <summary> "..." or '...' </summary>
        </member>
        <member name="F:LiteDB.TokenType.Int">
            <summary> [0-9]+ </summary>
        </member>
        <member name="F:LiteDB.TokenType.Double">
            <summary> [0-9]+.[0-9] </summary>
        </member>
        <member name="F:LiteDB.TokenType.Whitespace">
            <summary> \n\r\t \u0032 </summary>
        </member>
        <member name="F:LiteDB.TokenType.Word">
            <summary> [a-Z_$]+[a-Z0-9_$] </summary>
        </member>
        <member name="T:LiteDB.Token">
            <summary>
            Represent a single string token
            </summary>
        </member>
        <member name="M:LiteDB.Token.Expect(LiteDB.TokenType)">
            <summary>
            Expect if token is type (if not, throw UnexpectedToken)
            </summary>
        </member>
        <member name="M:LiteDB.Token.Expect(LiteDB.TokenType,LiteDB.TokenType)">
            <summary>
            Expect for type1 OR type2 (if not, throw UnexpectedToken)
            </summary>
        </member>
        <member name="M:LiteDB.Token.Expect(LiteDB.TokenType,LiteDB.TokenType,LiteDB.TokenType)">
            <summary>
            Expect for type1 OR type2 OR type3 (if not, throw UnexpectedToken)
            </summary>
        </member>
        <member name="T:LiteDB.Tokenizer">
            <summary>
            Class to tokenize TextReader input used in JsonRead/BsonExpressions
            This class are not thread safe
            </summary>
        </member>
        <member name="M:LiteDB.Tokenizer.CheckEOF">
            <summary>
            If EOF throw an invalid token exception (used in while()) otherwise return "false" (not EOF)
            </summary>
        </member>
        <member name="M:LiteDB.Tokenizer.IsWordChar(System.Char,System.Boolean)">
            <summary>
            Checks if char is an valid part of a word [a-Z_]+[a-Z0-9_$]*
            </summary>
        </member>
        <member name="M:LiteDB.Tokenizer.ReadChar">
            <summary>
            Read next char in stream and set in _current
            </summary>
        </member>
        <member name="M:LiteDB.Tokenizer.LookAhead(System.Boolean)">
            <summary>
            Look for next token but keeps in buffer when run "ReadToken()" again.
            </summary>
        </member>
        <member name="M:LiteDB.Tokenizer.ReadToken(System.Boolean)">
            <summary>
            Read next token (or from ahead buffer).
            </summary>
        </member>
        <member name="M:LiteDB.Tokenizer.ReadNext(System.Boolean)">
            <summary>
            Read next token from reader
            </summary>
        </member>
        <member name="M:LiteDB.Tokenizer.EatWhitespace">
            <summary>
            Eat all whitespace - used before a valid token
            </summary>
        </member>
        <member name="M:LiteDB.Tokenizer.ReadWord">
            <summary>
            Read a word (word = [\w$]+)
            </summary>
        </member>
        <member name="M:LiteDB.Tokenizer.ReadNumber(System.Boolean@)">
            <summary>
            Read a number - it's accepts all number char, but not validate. When run Convert, .NET will check if number is correct
            </summary>
        </member>
        <member name="M:LiteDB.Tokenizer.ReadString(System.Char)">
            <summary>
            Read a string removing open and close " or '
            </summary>
        </member>
        <member name="M:LiteDB.Tokenizer.ReadLine">
            <summary>
            Read all chars to end of LINE
            </summary>
        </member>
    </members>
</doc>
